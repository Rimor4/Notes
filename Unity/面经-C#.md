# C\#

## GC

### 如何避免 GC

1. 减少临时变量的使用，多使用**公共对象**，多利用**缓存**机制。（将容器定义到函数外，用到容器的时候进行修改即可）
2. 减少 `new` 对象的次数。
3. 对于大量字符串拼接时，将 **StringBuilder** 代替 String。（string 不可修改性，修改即创建一个新的 string 对象，旧的直接抛弃等待 GC，但少量字符串拼接用 string，性能优于 stringbuilder）
4. 使用扩容的容器时，例如：List，StringBuilder 等，定义时尽量根据存储变量的内存大小定义储存空间，**减少扩容**的操作。（扩容后，旧的容器直接抛弃等待 GC）
5. 代码逻辑优化：例如计时器当大于 1s 后才进行文本修改，而不是每帧都修改，或者禁止在关键时候 GC，影响游戏性能，可以在**加载页面**或者**进度条**的时候 GC。
6. 利用**对象池**：对象池是一种 Unity 经常用到的内存管理服务，针对经常消失生成的对象，例如子弹，怪物等，作用在于减少创建每个对象的系统开销。在我们想要对象消除时，不直接 Destory，而是隐藏起来 SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。
7. 减少**装箱拆箱**( 装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程)的操作
8. 协程： `yeild return 0` 会产生装箱拆箱，可以替换为 `yeild return null`。

## 结构体和类

### 结构体和类的区别

1. 结构体是**值**类型，类是**引用**类型。
2. 结构体存在**栈**中，类存在**堆**中。
3. 在 C#中**结构体**类型定义时，成员是不能初始化的,这样就导致了，定义结构体变量时,变量的所有成员都要**自己赋值初始化**。但对于**类**，在定义类时,就**可以初始化**其中的成员变量,所以在定义对象时,对象本身就已经有了初始值,你可以自己在重新给个别变量赋值。(注意在 C++中，类的定义中是不能初始化的，初始化要放在构造函数中)
4. 结构体不能申明**无参的构造函数**，而类可以。
5. 声明了结构类型后，可以使用 `new` 运算符创建构造对象，也可以不使用 `new` 关键字。如果不使用 `new`，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。
6. 结构体申明**有参构造函数**后，**无参构造不会被顶掉**。
7. 结构体不能申明**析构函数**，而类可以。
8. 结构体不能被**继承**，而类可以。
9. 结构体需要在构造函数中**初始化所有成员变量**，而类随意。
10. 结构体不能被静态 `static` 修饰(不存在静态结构体)，而类可以

## 容器类

### 性能对比

1. 插入性能： LinkedList > Dictionary > HashTable > List
2. 遍历性能：List > LinkedList > Dictionary > HashTable
3. 删除性能： Dictionary > LinkedList > HashTable > List
