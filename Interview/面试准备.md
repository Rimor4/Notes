#  2025.12 

## 自我介绍

面试官好，我叫王锋奇。是个重度主机游戏玩家，也是个游戏开发爱好者。目前就读于复旦大学软件工程专业，预计于2027年毕业 。在校期间，除了系统掌握了计算机专业知识外，我前后参加过两次GameJam比赛，分别开发了平台跳跃类和肉鸽卡牌类两个完整的游戏demo，之后通过实习和个人项目，构建了UE与Unity双引擎的开发能力 。目前我的兴趣聚焦于Gameplay开发，平时除了热衷拆解大型游戏项目，也致力于钻研底层技术与架构设计。

之前在莉莉丝实习期间，我参与了一款大世界SOC项目的开发 。这段经历极大地锻炼了我的工程落地能力，其中最有成就感的工作主要体现在三个方面：

第一是我独立负责了**多人组队系统**的开发，基于项目Lua 侧**ECS**架构和**UI框架**，在保证组队系统与其他业务系统的低耦合前提下，成功落地了社交组队、地图队伍追踪、组队任务等功能并完成了全套UI交互的开发。

其次，我深入重构了项目的“红点系统” 。 通过代码实现**数据与表现的分离**，以及支持策划更灵活地配置如父级选择即消除等规则，~~显著提升了系统的可维护性。~~

此外，我还主动拓展了工作边界 。参与了部分**战斗**开发，编写了技能后处理类特效的运行时逻辑与编辑器工具；同时负责了部分性能优化的工作，针对一部分ECS网络同步系统进行优化，实现了**正常跑图时的“零GC”**，有效提升了游戏帧率。

除了工作交付，我利用业余时间深入钻研了 UE5 技术栈 。 为了吃透 **UE GAS (Gameplay Ability System)**，我独立开发了一个俯视角RPG Demo，基于GAS构建了完整的技能与属性框架 。 同时，我也深度拆解了 **Lyra** 示例项目，研究了其模块化的Gameplay架构以及动画与AI模块。最近，我正在尝试使用 **UE5 状态树** 重写原本基于行为树的AI逻辑以探索更高效的行为控制方案 。

我立志成为一名兼具技术深度和产品意识的客户端工程师。非常希望能在 [XX公司] 发挥我的工程落地能力，和优秀的团队一起打造高品质的游戏产品。以上就是我的个人介绍，谢谢您。



“您好，我是王锋奇，目前就读于复旦大学软件工程专业。我是一名重度的主机游戏玩家，也是一名游戏开发爱好者。

不仅具备扎实的计算机专业基础，更在校期间通过两次 GameJam 比赛完成了从 0 到 1 的项目落地。此前，我在**莉莉丝游戏**的大世界 SOC 项目中担任客户端开发实习生。这段经历让我完成了从‘学生’到‘开发者’的转变。

在实习期间，我的工作不仅限于代码编写，更侧重于**解决复杂的业务逻辑和优化协作流程**：

1. **独立负责核心模块**：我主导了多人组队系统的开发，不仅完成了复杂的功能开发，还通过架构设计确保了社交、地图、任务等多系统间的低耦合，保证了代码的健壮性。
2. **优化团队协作效率**：我重构了红点系统，通过数据与表现的分离，让策划同学能更灵活地配置规则，让其他程序同学更便利地使用这套框架。我非常享受这种通过技术手段提升整个团队生产力的过程。
3. **极强的自驱力与解决问题能力**：我主动承担了性能优化和战斗系统的工作，通过对底层逻辑的钻研实现了‘零GC’的优化效果，有效提升了玩家的帧率体验。

在业余时间，我保持着对前沿技术的探索，通过深入拆解 UE5 工业级示例项目（如 Lyra）和自研 RPG Demo，构建了完整的 UE 与 Unity 双引擎开发能力。

我立志成为一名兼具技术深度和产品意识的客户端工程师。非常希望能在 [XX公司] 发挥我的工程落地能力，和优秀的团队一起打造高品质的游戏产品。”





## 问面试官的问题

- 是否review代码

- 我想了解一下我们团队在测试上的具体做法：
  我之前在做组队系统时尝试过 TDD，但效果不是很好——表现层的测试很难写，而且测试代码也比较容易随着功能变动而失效。另外在和后端联调时，我感觉很多“测试”可能用日志就能覆盖，所以想问一下你们在这方面有没有更成熟的经验？

  此外，我也比较好奇的是，你们有没有自动化集成测试的做法，比如能自动跑一遍关键交互场景的自动化流程？以及代码库中会不会保留测试用例

  最后，如果要重构别人写的复杂逻辑，在缺少自测试的情况下很难确保安全性。团队在重构这类代码时一般怎么保障质量呢？

  

  快问快答：

- 如果可以入职的话，hc

- 在战斗组具体是哪方面的工作？快上线了，会不会主要修bug而不是功能开发

- 有没有导师（一对一）培养  【听说对比网易，会丢给实习生一堆活，显得培养的好】



​      请教：

- ~~学习路径~~

- ~~测试（已经问过了），重构（一个新功能单子，老同事已经走了，优先重构还是屎山上继续堆，对于修改别人代码的建议~~

- gameplay程序学习要平衡广度（动画、各种gameplay架构、网络同步、移动）和深度，深度方面要学到多深？

- ~~算法：从计算机系统角度[不学习系统的细节不可能学会一个系统] ，但是算法呢，每个（渲染/动画等）算法/数学层面的细节是否都需要掌握？因为自己现在学习渲染的时候有些数学上的细节会略过~~

- 自己的简历/面试表现

- ~~引擎对gameplay程序员影响？~~

- ~~为什么流程这么慢~~



- 转正机制是怎么样的
- ~~培养制度/导师制度具体是怎么样~~
- ~~为加入3a项目，对人才会有哪些更高的要求吗（当时打算问）~~
- ~~接下来的学习路径，学了lyra，打算学一下ue5版的ALS，AI方向呢~~
- ~~如果有幸入职，您建议我还需要在哪些技术或者技能方面做进一步准备？~~
- vibe coding和自己写代码如何平衡（学习阶段）
- 公司的企业文化
- 流程为什么有点慢
- ~~实习生的薪酬体系怎么样、房补？~~
- 公司的实习生**薪资构成**和**福利待遇**大概是什么样的(日薪/月薪)
- 周一入职？

谢谢解答



## 可能问的问题

### 实习项目

#### 红点系统

1. 关于“数据-表现分离”的设计思路。 “什么是‘单节点多类型红点’？如何支持策划灵活配置‘消除规则’的？” 

   前者是为了更好的支持后两者。单节点是数据类Node，一个**Node**中可以有多个**Key**（key代表一种信息比如任务进度更新/任务被追踪，有不同的红点），每个Key对应一个**View**。首先策划通过配置 

   ```
   {前缀树+Key} 
   	 |
   	\|/
   {消除规则【特殊的”选择即消除“是通过在每一个节点中额外维护一个已阅标记实现的】、红点样式、是否可被子类“穿透”等}
   ```

   在数据类中依据配置信息+已阅标记+过滤器模式技术最终筛选生成出来一个中间数据（可能包含了多个可显示的红点样式），再把这个中间数据传到View类中根据优先级显出来一个最后的红点图标。

2. 关于“红点树的维护”？

   为了避免同一帧内多个子节点变化导致父节点重复计算，出现状态不一致或闪烁。，引入了 **Dirty Flag脏标记**。每帧update时从root开始，

   update的时候

   主要通过路径缓存来优化节点查询/更新等操作。

##### 遇到的挑战

方案的选择：如何增加选择即消除这一特殊规则、如何保存红点存档

#### 组队系统

##### 遇到的一些挑战/问题

1. 服务器正常通过AOI同步其他玩家的装备、外观等数据，离开同一AOI后会清掉数据，但是无论远近，同个小队的这些数据需要一直保留（随时可能打开组队面板，能看到队友的当前外观、手持武器等）

1. 社交专用的提示组件：（ux要后来的顶掉前面的，且后来的被确定后再显示前面的）完全用了单实例（过早优化）+动画状态机的思路，应该还有更简洁的方案（犯了”夸夸其谈通用性“）。

   

#### 区域同步

- Req-Ack：客户端按需拉取，需要时（主控自己维护宫格移动到没有的数据就请求）

- 宫格订阅：和服务器重新约定协议，服务器下发宫格数据（宫格矩形两个角的坐标和矩形内的区域数据）。

  为解决主控跨宫格时同步的滞后等问题：服务器给客户端下发的数据范围实际上比那个”宫格范围“大一圈，这样能达到跨宫格重新订阅时边界数据已经在了。抖动问题可能在服务器侧解决（对于客户端是透明的）。猜测可能也是通过类似的方法。（退出半径比进入半径大）

- 全图同步：由于相关需求的变更（增加了地图查看全地图感染区），必须时刻同步全图的区域数据，用服务器分帧更新/同步，客户端业务逻辑查询用分块优化。（如某个业务侧查询xxx点的区域信息，只遍历对应块的数据）

#### CPU性能优化

Unity侧GC

- 主要在业务逻辑不必要的重复**读表**（策划配的表）
- 消除字符串拼接、字符串传递（C#会在托管堆上分配内存），lua侧字符串能用int代替就用int（Hash）
- 避免闭包。

减少重复更新，减少同一帧CPU处理时间



**问：为什么只看 Unity 侧的 GC？**

Lua 侧的 GC 属于 **Lua 虚拟机**（内部 Table 分配），而 Unity Profiler 监控的是 **C# 托管堆（Managed Heap）**。

**真正的卡顿来源**：Unity 侧的 GC 触发（Garbage Collect）通常是全局性的，会导致明显的“掉帧”（Stop-the-world）。



#### Lua侧ECS框架

1. 架构：

   没有用Unity官方的Archetype+Chunk的数据组织方式（lua侧就直接是table

- Entity只作为一个ID；
- Component数据来源是服务器Protocol Buffer;
- System只包含逻辑，不持有状态，为了简化，一个System只处理一种Component



2. “Lua 本身是基于动态 Table 的，无法像 C++ 那样保证绝对的内存连续，那你在 Lua 里用 ECS 还有意义吗？”

   即便不追求极限的内存连续，ECS 也能解决大世界项目中复杂的逻辑耦合问题，实现**数据与表现的彻底分离** 。



#### UI框架

- 项目是MVC架构(横向)

- 分层

- 栈状态机（纵向）

- 基类提供一系列的生命周期回调

- View与Logic分离，支持自动导出View，绑定到UGUI
- Controller可以调用View中的“数据接口”获取UGUI的组件

```
导出View：
在 UGUI 的 Prefab 上，通过特定的命名规则（如 txt_Name、btn_Confirm），在编辑器中完成UI搭建后即可一键自动导出对应的lua侧代码模板，区分View和Ctrl；
每个组件都被映射为一个属性，例如：self.btn_Confirm = transform:Find("path/to/button"):GetComponent("Button")。
自动绑定接口：在 UI 框架的 OnOpen 或 Awake 阶段，自动调用生成的绑定函数，将 Prefab 上的实例赋值给 Lua Table 中的变量。
```



### Lyra

#### UI框架（CommonUI）

- **Lyra 的 UI 层级结构**：Lyra 定义了四层 UI 结构，从低到高为 Game、GameMenu、Menu、Modal 层。层级配置在 GameUIPolicy 类中，由 GameUIManagerSubsystem 管理并在 DefaultGame.ini 文件中设置。每层有明确用途，像 Game 层放置特定的 LyraHudLayout UI，GameMenu 层放置局内非主界面 UI，Menu 层放置局外非主界面 UI，Modal 层作为通知层，这种分层结构让 UI 管理更有序。
- **各层 UI 的生成与交互**：Game 层 UI 借助 **GameFeatures** 动态添加，涉及一系列初始化与加载流程，还能设置返回键路由界面；GameMenu 层 UI 通过 **GA** 触发，依赖玩家状态相关设置，技能触发时生成 UI；Menu 层 UI 主要源于按钮点击；Modal 层用于放置通知及特定设置 UI。各层 UI 生成方式不同，且存在如返回键操作关联不同层 UI 等交互逻辑，共同构成完整 UI 体系。

#### 动画

##### 动画更新流程

[动画蓝图更新流程 - 南京周润发](https://zhuanlan.zhihu.com/p/676529450)

回答的核心逻辑必须清晰地分为两个阶段：**Update（逻辑更新）** 和 **Evaluate（姿态评估）**。这是 UE 动画系统的基石。

你可以按照以下 **“总-分-微观”** 的结构来组织回答：

------

1. 总述：核心架构（Update vs Evaluate）

> “UE 的动画系统为了支持多线程并行优化，核心流程被严格拆分为两个阶段：**Update（更新）** 和 **Evaluate（评估）**。
>
> - **Update**：负责计算‘我们要播放什么？’（计算时间、权重、状态机跳转）。通常在 **GameThread**（或者 Worker 线程的 Update 阶段）执行。
> - **Evaluate**：负责计算‘骨骼具体在哪？’（计算 Bone Transform）。为了性能，这一步通常是在 **Worker Threads**（并行评估）中执行的。”

------

2. 第一阶段：Update (逻辑更新)

这是动画数据的准备阶段。

- **入口**：`USkeletalMeshComponent::TickComponent` 触发。
- **数据收集 (Gathering Data)**：
  - **Proxy 机制**：UE 为了线程安全，设计了 `FAnimInstanceProxy`。主线程的数据（如角色速度、状态）会被拷贝到 Proxy 中。**Lyra 的 Thread Safe Update** 就是为了让这一步也能并行化，避免在 GameThread 访问非线程安全的数据。
- **计算 (Calculation)**：
  - 遍历动画树（AnimGraph），调用每个节点的 `Update_AnyThread`。
  - **状态机**：判断是否切换状态（State Machine Transition）。
  - **时间推进**：更新动画的 `CurrentTime`，处理循环、Notify 触发。
  - **权重计算**：计算各个 Blend 节点的 Alpha 值（比如混合 50% 的走和 50% 的跑）。
- **关键点**：此时**不涉及**具体的骨骼坐标计算，只处理逻辑变量。

------

3. 第二阶段：Evaluate (姿态评估)

这是最消耗 CPU 的数学计算阶段，也是优化的核心。

- **入口**：通常在 `ParallelAnimationEvaluation` 任务中触发。
- **递归遍历**：从 Root Node 开始，调用 `Evaluate_AnyThread`，一直递归到叶子节点（如 `AnimSequencePlayer`）。
- **叶子节点 (Leaf Nodes)**：
  - 解压动画压缩数据（Decompression），根据当前的 Time 获取原始的骨骼姿态（Local Pose）。
- **中间节点 (Blend Nodes)**：
  - 执行混合运算（Lerp）。比如 Layered Blend Per Bone，会将两个来源的 Pose 按骨骼遮罩进行混合。
- **输出结果**：
  - 最终生成一个 `FCompactPose`。这是一个**针对缓存优化（Cache Friendly）**的紧凑数组结构，存储了所有骨骼的 Transform。



##### 重要函数更新顺序

第一阶段：初始化（只执行一次）

当一个角色被 Spawn 或者 `SkeletalMeshComponent` 初始化时：

1. **`NativeInitializeAnimation` (C++)**
   - 最早执行，用于缓存组件引用、初始化变量。
2. **`BlueprintInitializeAnimation` (Blueprints)**
   - 蓝图中的 `Event Blueprint Initialize Animation`。
3. **AnimNode `Initialize_AnyThread`**
   - 动画蓝图（AnimGraph）中每个节点的初始化。注意后缀 `_AnyThread`，意味着它可能在后台线程重置（比如状态机重置时）。

------

第二阶段：每一帧的更新循环（核心流程）

这个流程非常关键，分为 **Game Thread（主线程准备数据）** 和 **Worker Thread（后台线程计算数据）**。

1. 主线程准备 (Game Thread)

由 `USkeletalMeshComponent::TickComponent` 触发。

- **`NativeUpdateAnimation` (C++)**
  - **老式/非线程安全**。这是最传统的入口，用于每一帧在主线程获取 Pawn、Controller 等数据。
  - *缺点*：会阻塞主线程，Lyra 极力避免在这里做繁重逻辑。
- **`BlueprintUpdateAnimation` (Blueprints)**
  - 对应蓝图中的 `Event Blueprint Update Animation`。
  - **警告**：这也是运行在主线程的！很多新手喜欢在这里写一堆逻辑，导致游戏掉帧。

2. 并行更新开始 (Transition to Worker Thread)

此时，UE 会尝试将任务分发给后台线程。这里引入了 **Proxy (代理)** 概念。

- **`FAnimInstanceProxy::PreUpdate`**
  - 数据拷贝阶段。将主线程（AnimInstance）的数据拷贝到线程安全的代理（Proxy）结构体中。

3. 线程安全更新 (Worker Thread - 逻辑层)

这是 **Lyra** 和现代 UE5 推荐的逻辑处理位置。

- **`NativeThreadSafeUpdateAnimation` (C++)**
  - 你自定义的 C++ `UAnimInstance` 如果覆写了这个函数，它会在后台线程运行。在这里访问 `UObject` 是不安全的（除非使用 `TWeakObjectPtr` 或 Property Access）。
- **`BlueprintThreadSafeUpdateAnimation` (Blueprints)**
  - 对应蓝图中的 **`Event Blueprint Thread Safe Update Animation`**。
  - 这是 Lyra 放置状态机逻辑、Locomotion 计算的核心位置。它极快，因为它不通过蓝图虚拟机与主线程交互，只操作局部数据。

4. 动画图表更新 (Worker Thread - AnimGraph Update)

逻辑计算完毕后，引擎开始**从根节点（Root）向下**遍历动画图表，计算“权值”和“时间”。

- **AnimNode `Update_AnyThread`**
  - **顺序**：从 Root Node -> Blend Nodes -> Leaf Nodes (Sequence Player)。
  - **职责**：
    - 推进动画时间（Time Advancement）。
    - 解析 Notify（加入队列，稍后在主线程触发）。
    - 计算混合权重（Alpha）。
    - **注意**：这里**不产生**骨骼姿态，只计算“要播放多少秒”、“混合比例是多少”。

5. 动画图表评估 (Worker Thread - AnimGraph Evaluate)

这是最耗时的步骤。引擎**从根节点（Root）向叶子节点（Leaf）拉取（Pull）\**数据，然后\**从叶子向根**返回姿态。

- **AnimNode `Evaluate_AnyThread`**
  - **顺序**：Root 请求数据 -> 递归调用子节点 Evaluate -> 子节点解压动画数据 -> 返回 `FPoseContext` -> 父节点混合（Lerp）。
  - **职责**：
    - **Leaf Node**：解压骨骼 Transform。
    - **Blend Node**：执行数学混合（如 `Blend Per Bone`）。
    - **SkeletalControl / Control Rig**：执行 IK、LookAt 等骨骼修正。
  - **输出**：最终生成 `FCompactPose`（紧凑的骨骼数组）。

6. 后处理与应用 (Post-Process)

回到主线程或渲染线程同步。

- **`NativePostEvaluateAnimation` (C++)**
  - 评估完成后的回调，通常用于调试或极特殊的后处理。
- **Swap Buffers & Render**
  - 将计算好的 Transform 提交给渲染线程，更新 Skinned Mesh。
- **Trigger Notifies (Game Thread)**
  - 注意！**AnimNotify 是在所有计算完成后，在主线程触发的**。所以 Notify 里的逻辑如果修改了变量，是**下一帧**才会生效。

------

总结图谱（面试速记版）

如果面试官让你画出顺序，按这个写绝对满分：

1. **[GT] NativeUpdateAnimation** (传统入口，Lyra 几乎不用)
2. **[GT] BlueprintUpdateAnimation** (传统蓝图入口)
3. **[COPY] Proxy Data Copy** (主线程 -> 代理)
4. **[WT] NativeThreadSafeUpdateAnimation** (现代 C++ 逻辑核心)
5. **[WT] BlueprintThreadSafeUpdateAnimation** (现代蓝图逻辑核心 - Lyra Locomotion 在此)
6. **[WT] Graph Update** (计算时间/权重)
   - `Node::Update_AnyThread`
7. **[WT] Graph Evaluate** (计算骨骼位置/IK)
   - `Node::Evaluate_AnyThread`
8. **[GT] Fire Notifies** (触发音效/特效)



##### 性能优化

1. **URO**：

   ![](D:\Projects\NOTES\images\v2-9a14fd9bf3eb8fb67f670aab7123ccb5_r.jpg)

2. **ShifitBucket**：负载均衡：让不同的角色更新错峰进行

3. EvaluateRate可以比UpdateRate低一点

4. **LOD**：也可以省略远处的IK解算、动画通知等计算，还可以移除部分骨骼（LOD预先设定好的RequiredBones）

5. **LeaderPoseComponent**

   > 有一个东西叫做LeaderPoseComponent，如果它存在的话并且bFollowerShouldTickPose为false的话，自己就不去TickPose了，而是从LeaderPoseComponent输出的Pose中取。
   >
   > 当然，这玩意不止应用于SKM的拆分，还会应用于群体动画。假如我有一堆角色，它们的骨骼结构是相同的，并且要执行相同的动画，那么就完全不需要每一个都去更新和评估，而是只需要一个角色的SKM作为LeaderPoseComponent，别的作为它的从属，这样LeaderPoseComponent输出的Pose就能被别的角色共用了。

6. `EVisibilityBasedAnimTickOption` 决定各种情况下要不要进行 TickPose 和 RefreshBoneTransforms。

7. 缓存：动画节点通过**CacheBones_AnyThread**缓存动画所引用的骨骼索引等

###### **LeaderPose、**CopyPose** 和 **MeshMerge**对比

1. Leader Pose Component

这是最常用的模块化角色实现方式。

- **原理**：指定一个“领头”组件（Leader），其他“跟随”组件（Follower）直接复用 Leader 的**骨骼变换缓冲（Bone Transform Buffer）**。
- **优点**：
  - **CPU 开销极低**：跟随组件不运行任何动画逻辑，不更新 AnimBP，节省了大量的 Game Thread 计算。
  - **同步完美**：因为共用同一套骨骼数据，绝对不会出现穿模或同步延迟。
- **缺点**：
  - **灵活性差**：跟随组件不能有自己的动画逻辑，无法运行独立的物理模拟（如布料或物理须子）。
  - **渲染开销未减**：虽然节省了 CPU 动画计算，但 Draw Call（绘制调用）数量没有减少，每个部件仍是独立的渲染批次。
  - **骨骼限制**：跟随组件的骨骼结构必须是 Leader 骨骼的子集。

2. Copy Pose From Mesh

这是一种基于动画蓝图（AnimBP）节点的方案。

- **原理**：在跟随组件的 AnimBP 中使用 `Copy Pose From Mesh` 节点，每帧从目标 Mesh 拷贝当前的骨骼姿态。
- **优点**：
  - **高度灵活**：拷贝完姿态后，你可以继续在该组件的 AnimBP 中添加额外的动画逻辑（如 Control Rig、LookAt、动力学效果等）。
  - **支持不同骨骼**：只要骨骼名称匹配即可拷贝，不要求完全一致的骨架结构。
- **缺点**：
  - **CPU 开销最大**：每个跟随组件都需要运行自己的 AnimBP。
  - **可能存在延迟**：如果组件的 Tick 顺序不当，可能会看到跟随组件比主体慢一帧。

3. Mesh Merge (Skeletal Mesh Merge)

这是一种在底层将多个 Skeletal Mesh 合并成一个 Mesh 的技术。

- **原理**：在运行时（通常是角色生成时）将多个网格体及其材质合并成一个单一的网格体资产。
- **优点**：
  - **渲染性能最强**：极大地减少了 **Draw Call**。合并后，原本 10 个部位可能只需要 1 个 Draw Call（取决于材质数量）。
  - **动画开销低**：只需要为一个组件计算动画。
- **缺点**：
  - **合并开销**：在执行合并的瞬间会有明显的 CPU 掉帧（Hitch），通常在加载界面或后台处理。
  - **材质局限**：如果各部件材质不同，合并后可能需要处理复杂的 Texture Atlas（纹理图集）。
  - **维护复杂**：不支持 Morph Targets（混合形状）的动态合并（除非使用特殊插件如 Mutable）。



##### 多线程

主线程更新：

<img src="D:\Projects\NOTES\images\v2-a1df1a24be903f7a4a3972fd67c7b603_1440w.jpg" alt="img" style="zoom:50%;" />

多线程更新：

![img](D:\Projects\NOTES\images\v2-a9daf51b9c51669807a691be79ea4a51_r.jpg)



##### Lyra 的“模块化动画”

1. 同种动画状态，但状态内容不同时，如何解耦不同的状态内容（使用**动画层**解耦）<img src="D:\Projects\NOTES\images\v2-7a66f1bf107eb0ec877d5644a04c02d0_r.jpg" alt="img" style="zoom: 50%;" />

   LinkAnimClassLayers函数:
   	利用反射机制将原始蓝图上的LinkNode指向目标蓝图上相同的LinkNode，然后在更新时进行跳转即可。

   

2. Locomotion 如何避免 “滑步”

   【本质是用移动组件的位移去驱动动画进度】

   - a. **启动动画**怎么避免滑步

     **Advance Time By Distance Matching（函数）** 每帧让“启动动画中反映每帧位移量的 Curve(DistanceCurveName)   的进度” **匹配上** 传入的 “实际**每帧位移**量”(DistanceTraveled) ，然后进行播放速率缩放，使得动画匹配移动速度。

   - b. **循环动画**怎么避免滑步

     **SetPlayRateToMatchSpeed（函数）** 每帧用 传入的“角色实际速度 (cm/s)” (SpeedToMatch) 除以 “循环动画 RootMotion 的移动速度(总RootMotion距离除以动画长度)” 得到期望的播放速率的缩放率并设置到SequencePlayer

   - c. **停止动画**怎么避免滑步

     **DistanceMatchToTarget（函数）** 每帧让 “停止动画中指定的 Curve 的进度”匹配上 传入的 “距离到停止点距离” (DistanceToTarget) (由PredictGroundMovementStopLocation算出) ，输出对应帧，使得动画匹配移动速度。

   - d. **动画的步幅**如何更好的匹配实际移动速度

     **Stride Warping(步幅扭曲函数)** 每帧根据 “实际速度 (cm/s)” 比上 “动画 RootMotion 的速度”对双足水平距离进行缩放, 并通过IK调整盆骨位置，最终使得双足的步幅能和移动速度匹配

   

3. 如何原地转身（TurnInPlace）

   为了控制整个骨骼的旋转不受角色旋转影响，在 Lyra 中，解决的方式是通过 “RotateRootBone” 节点来旋转 Root 骨骼，通过输入 Yaw 轴的补偿值来 “抵消”Character 本身旋转产生的 Yaw 值。这个补偿值的变量名为 **RootYawOffset**。

   Lyra 中只有在 Idle 状态才能触发 TurnInPlace 效果，**RootYawOffset** 值只有在 Idle 和 Stop 这两个状态下才会进行计算，其他状态下都只会向 0 进行插值（0 的话就是没有补偿，Root 朝向和角色 Actor 朝向一致）。

4. 如何不使用 BlendSpace 做出 Locomotion 的全向混合效果

   **Orientation Warping**

   <img src="D:\Projects\NOTES\images\image-20260115233909829.png" alt="image-20260115233909829" style="zoom: 67%;" />

   

5. 如何做急停反向移动（Pivot）
   双状态处理不断反向（ue没有状态机重进功能）

   ```
   a. 在StartState或者CycleState中，侦测到速度和加速度方向相反，则进入PivotState
   b. PivotState中，Tick判断加速度方向和速度方向是否一致
   c. 若不一致，表明还处于“刹车”过程中，当做Stop状态来处理，使用DistanceMatchToTarget函数
   d. 若一致，表明已经到达了Pivot点，并开始向反向移动，此时当做Start状态来处理，使用AdvanceTimeByDistanceMatching函数
   ```

6. 双足 IK 如何实现

   FootPlacement / ControlRig



#### Gameplay框架

##### ModularGameplay

给原有的**PlayerController**等大类外面套一层子类**ModularPlayerController**，在初始化时用 `UGameFrameworkComponentManager::AddGameFrameworkComponentReceiver(this);` 侵入式地注册为GFCM中的Recevier；

之后继承**UGameFrameworkComponent**的各种Component (如 **ULyraControllerComponent_CharacterParts** -> **UControllerComponent**(表示绑在ModularPlayerController中的comp) -> UGFC) 在Controller中调用 **ReceivePlayer**（初始化）和**PlayerTick**（更新）等生命周期函数。

相比原先的Actor - Component组合方案，主要现在可以支持动态添加（通过Experience->**GameFeature**)



#### 状态树

[StateTree 架构深度源码解析：核心机制、内存布局与执行流水线](https://zhuanlan.zhihu.com/p/1975009910996615830)

<img src="D:\Projects\NOTES\images\StateTree运行逻辑.png" alt="StateTree运行逻辑"  />

##### 一、 初始化流程（Initialization）

当 StateTree 开始运行（Tree Start）时，系统会进行数据准备和初始状态选择。

1. **Evaluator 数据准备**：
   - 首先调用所有 Evaluator 的 `TreeStart`，随后执行一次 `Tick`。
   - **目的**：在状态选择前，预先从环境中提取并处理好必要的数据（如感知到的敌人信息、玩家距离等）。
2. **初始状态选择（SelectState）**：
   - 目标状态默认为 **Root**。
   - **条件判定**：自根向叶检查 `Enter Conditions`，判断哪些子状态可以被激活。
   - **Task 入场**：一旦确定了激活路径，系统会**自根到叶（正序）**依次调用路径上每个 State 中 Task 的 `EnterState`。

------

##### 二、 运行时每帧更新（Tick）

StateTree 的 Tick 分为两个主要部分：数据更新与 Task 执行。

1. **Evaluator 更新**：

   - 每帧最先调用 `Evaluator's Tick`，更新全局或上下文数据。

2. **Task 逻辑执行**：

   - **执行顺序**：**自根到叶（正序）**调用每个激活状态里 Task 的 `Tick`。
   - **阻断机制**：如果某个 Task 在 Tick 中返回了“成功”或“失败”，系统会**停止后续（更深层级）Task 的 Tick**。

3. **任务完成处理（StateComplete）**：

   - 一旦 Task 完成（不再返回 Running），系统会**自叶到根（逆序）**调用所有已激活状态中 Task 的 `StateComplete`。

4. 过渡流程（Transition）

   1. **条件检查**：

      - **执行顺序**：**自叶到根（逆序）**检查 Transition 上的 Conditions 是否满足。
      - **逻辑逻辑**：子状态（叶子）通常具有更高的逻辑优先级，若子状态满足跳转条件，则优先触发。

   2. **退出旧状态**：

      - 如果条件满足，系统会**自叶到根（逆序）**依次调用当前路径上所有 Task 的 `ExitState`，清理旧状态逻辑。

   3. **进入新状态**：

      - 调用 `SelectState` 跳转至目标状态（Target State），重新开始“自根到叶”的 Enter 流程。

      - **SelectState**流程
        - **识别目标：** 系统首先解析目标状态句柄（State Handle）。
        - **寻找共同祖先：** 这是一个关键的算法步骤。执行上下文在树的层级结构中向上回溯，直到找到当前状态（Current State）和目标状态（Target State）的**最近公共祖先**（或者根节点）。
        - **退出阶段（Exit Phase）：** 系统自底向上（From Leaf to Root）调用所有状态的 `ExitState()`，直到（但不包括）共同祖先。
        - **进入阶段（Enter Phase）：** 系统自顶向下（From Root to Leaf）调用从共同祖先到新目标叶子节点路径上所有状态的 `EnterState()` 。

##### 数据绑定与属性传播机制

在 UE5 的 **StateTree** 体系中，数据绑定（Data Binding）与传播机制是其区别于行为树（Behavior Tree）最核心的特性之一。它通过显式的**属性链接（Property Link）**代替了行为树中基于字符串索引的黑板（Blackboard）模式。

以下是根据你提供的运行逻辑图及 UE5 核心机制进行的详解：

------

1. 数据绑定的核心概念：Schema 与 Context

在 StateTree 中，数据传播的起点是 **Schema（架构）**。

- **Schema 定义上下文**：每个 StateTree 必须选择一个 Schema（如 `StateTreeGameplayTasksSchema`）。Schema 规定了该树能访问哪些**外部数据**（Context Data），例如 `AActor`、`UAIPerceptionComponent` 或自定义的 `UObject`。
- **Context 注入**：当 StateTree 开始运行（初始化阶段），外部系统会将这些具体的对象实例注入到 StateTree 的**实例数据（Instance Data）**中。

------

2. 数据传播路径：Evaluator -> Task

第一步：Evaluator 的数据提取（数据源）

- **初始化阶段**：调用 `Evaluator` 的 `TreeStart` 和 `Tick`。
- **传播逻辑**：Evaluator 作为“传感器”，从 Context（如感知组件）中提取原始数据，并将其转化为 StateTree 内部易于处理的属性（如 `bIsEnemyVisible` 或 `TargetActor`）。
- **数据绑定**：Evaluator 定义的这些输出属性，可以被后续的 Task 或 Transition 直接绑定。

第二步：属性绑定（Property Binding）

- **显式链接**：在 StateTree 编辑器中，你可以直接将 Task 的输入参数“连线”到 Evaluator 的输出参数上。
- **底层机制**：这在底层是通过 **`FStateTreePropertyBinding`** 实现的。它不依赖黑板键的字符串查询，而是直接记录属性在内存中的偏移量（Offset），因此访问速度极快。

------



##### Behavior Tree vs. State Tree

| **特性**     | **Behavior Tree (行为树)**                                   | **State Tree (状态树)**                                      |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **设计范式** | **基于决策 (Decision-based)**。每帧（或事件触发）从根节点重新评估，寻找可执行的叶节点。 | **基于状态 (State-based)**。它是分层状态机 (HFSM) 的进化版，明确“当前正处于哪个状态”。 |
| **运行机制** | 依靠 **Selector/Sequence** 控制流，通过失败/成功反馈来回溯。 | 依靠 **Transition (过渡)** 驱动。状态切换是显式的，只有满足条件才进行状态跳转。 |
| **数据通信** | 强绑定 **Blackboard (黑板)**。数据读写往往需要显式的 Key 绑定。 | 采用 **Property Bag / Data Bindings**。支持更直接的属性引用，减少了黑板带来的维护成本。 |

2. 核心区别 (三大维度)

A. 决策机制：逻辑搜索 vs. 状态迁移

- **行为树 (BT)**：依靠**打断 (Interrupt)**。
  - BT 每一帧都在扫描优先级。如果低优先级的“巡逻”正在运行，但高优先级的“看到敌人”条件满足了，BT 必须通过**装饰器 (Decorator)** 强制中断当前任务。
  - *缺点*：当条件极多时，树上到处都是重复的装饰器，逻辑容易变成“意大利面条”。
- **状态树 (ST)**：依靠**过渡 (Transition)**。
  - ST 显式地定义了从 A 状态到 B 状态的连线。它只在当前状态完成或特定触发器触发时，才去评估“我该去哪”。
  - *优点*：逻辑流非常直观，像流程图一样，状态切换是受控且唯一的。

B. 性能模型：内存与评估效率

- **行为树 (BT)**：
  - 每个节点都是一个对象，且带有运行时状态。在大规模 AI（如几百个僵尸）时，内存开销和每帧扫树的 CPU 开销不容忽视。
- **状态树 (ST)**：
  - **极度紧凑**。ST 将所有数据存储在一个连续的内存块（Instance Data）中。它的评估过程类似于查表，且支持**并行化更新**。
  - *优势*：在同等硬件下，ST 能支撑的 AI 数量远超 BT。

C. **数据共享**：Blackboard vs. Data Bindings

- **行为树 (BT)**：通常绑定一个 **Blackboard (黑板)**。所有数据读写都要通过 String/Name 去查找黑板键，存在一定的开销且类型检查较弱。
- **状态树 (ST)**：使用了 **Property Bindings (属性绑定)**。它可以直接在编辑器里将一个 Task 的输出连到另一个 Task 的输入，类似于蓝图参数传递。这在开发时更安全，运行时也更高效。



### Aura

#### UI框架（MVVM的实践）

**MVC (Model-View-Controller)**：

- **Model**：数据层，负责存储和逻辑运算。
- **View**：表现层，负责显示（如 UGUI/UMG 里的 Prefab）。
- **Controller**：控制层，作为中转站。它监听 View 的输入，修改 Model；同时也监听 Model 的变化，去更新 View。
- **痛点**：Controller 容易变得非常臃肿（厚 C 问题），且 Controller 需要显式地持有 View 的引用，耦合度依然存在。

**MVVM (Model-View-ViewModel)**：

- **Model** 和 **View** 职责不变。

- **ViewModel**：不持有 View 的引用，它只负责暴露**可观察的数据（Observable Properties）\**和\**命令（Commands）**。

- **关键点**：引入了**数据绑定（Data Binding）**机制。View 和 ViewModel 之间是自动同步的，不需要手动在代码里写 `label.text = data.value`。

  （相当于框架帮你写了一些胶水代码，你只需要写接口

  个人理解：MVC像是面向”数据接口“（直接访问View的组件引用等数据）；而MVVM像是面向“行为接口”（VM中各种行为））

**A. 耦合度**

- **MVC**：在 Lua 侧，你的 Controller 通常需要写 `self.view.button:SetClick(...)`。这意味着 Controller 必须知道 View 的具体结构。
- **MVVM**：ViewModel 完全不知道 View 的存在。View 上的 UI 组件通过“绑定脚本”自动关联到 ViewModel 的某个字段。这意味着你换掉整个 UI 布局（View），只要变量名对得上，ViewModel 代码一行都不用改。

**B. 更新机制（如何“驱动”表现）**

- **MVC**：通常采用 **事件驱动**。Model 变了抛出一个 Event，Controller 收到 Event 后，手动调用 View 的更新接口。
- **MVVM**：采用 **数据驱动**。通过属性监听（如 C# 的 `INotifyPropertyChanged` 或 Lua 的 `setmetatable` 拦截）。当 ViewModel 的数值变了，UI 自动刷新。

后者可能**性能开销**更大，**调试困难**



#### GAS

[unreal5 GAS框架 源码深入解析（持续更新中） - 知乎](https://zhuanlan.zhihu.com/p/1919752469812061854)

1. GAS 整体实现与各模块功能

**面试官问：请简述 GAS 的整体架构，各核心模块是如何分工的？**

- **Ability System Component (ASC)：** 核心枢纽。它挂载在 Actor 上，负责管理所有的 Gameplay Abilities、Attributes、Gameplay Effects 以及 Gameplay Tags。它是所有 GAS 交互的入口。
- **Gameplay Ability (GA)：** 定义“做什么”。包含技能的触发逻辑、资源消耗（Cost）、冷却（Cooldown）以及具体的执行流程。它通常是异步的，通过 Ability Task 处理持续性逻辑。
- **Gameplay Effect (GE)：** 定义“改变什么”。是修改属性的唯一合法手段。它不仅可以做加减乘除，还能处理时长（Duration）、周期性触发（Period）以及复杂的叠加（Stacking）逻辑。
- **Attribute Set：** 存储数值。定义生命、魔法、力量等属性。它负责属性的计算逻辑（通过 `PreAttributeChange` 等钩子）和网络同步。
- **Gameplay Tags：** 系统的“粘合剂”。通过层级化的标签（如 `State.Frozen`）实现逻辑解耦。GA 的触发、GE 的过滤、甚至 UI 的显示都依赖于 Tag 的状态判断。
- **Gameplay Cue (GC)：** 表现层解耦。负责播放特效、音效，与具体的逻辑计算完全分离，优化了网络带宽（通过 RPC 触发一次性或循环表现）。



**激活一个技能流程**

PlayerState初始化/动态根据GameFeature添加 `GiveAbility`，内部注册这个技能AbilityTrigger中的Tag；

 主动触发GA: InputTag绑定的Press等输入事件->`TryActivateAbility` （check一系列条件，tag符合、cd、cost等，不行的话服务器在这里通过RPC告知客户端回滚）

被动触发：见下GE

**GE流程**

GE可以通过GrantedAbility赋予角色GA，再通过添加/移除Tag来自动触发GA

GE: UGameplayEffectComponent通过注册 `AllowGameplayEffectApplication` 函数来通过GameplayEffectQuery来实现自定义的复杂过滤逻辑

------

2. 网络同步、预测与回滚（重点：PredictionKey）

**面试官问：GAS 是如何处理客户端预测（Prediction）的？PredictionKey 的作用和生命周期是什么？**

#### **核心原理：**

GAS 使用一种“同步令牌”机制。当客户端尝试启动一个技能时，它会生成一个 **FPredictionKey**。

- **PredictionKey 的详细介绍：**
  - **定义：** 它是一个轻量级的结构体（包含序列号 ID），本质上是客户端向服务器发起请求时携带的“凭证”。
  - **生命周期：**
    1. **生成 (Client)：** 客户端按下按键，ASC 生成一个新的 `ScopedPredictionKey`。
    2. **发送 (RPC)：** 客户端将此 Key 随 `ServerTryActivateAbility` 发送给服务器。
    3. **本地执行：** 客户端在收到服务器回包前，基于此 Key **直接执行** GA 逻辑（如播放本地蒙太奇、扣除瞬时属性）。
    4. **服务器处理：** 服务器收到 RPC 后，使用相同的 Key 进行逻辑验证。如果验证通过，服务器执行逻辑并产生同步数据。
    5. **确认与销毁 (Replication)：** 服务器将处理结果（带有相同的 Key）同步回客户端。客户端发现服务器已处理该 Key，则将本地的预测标记为“已确认（Confirmed）”。
  - **功能：**
    - **防止逻辑重复：** 确保同一操作不会在两端重复触发两次。
    - **原子性：** 保证 GA 的激活、GE 的应用、Tag 的变更在同一个预测域内。

**预测与回滚的实现：**

- **属性同步：** GAS 并不通过回滚物理状态（如位置）的方式来处理属性。它依靠服务器的**权威同步**。
- **回滚机制：** 如果服务器拒绝了客户端的 GA 激活（例如：服务器判定蓝量不足），客户端会根据服务器发回的状态直接**覆盖**本地值。对于 GA，客户端会强制调用 `EndAbility` 并撤销预测产生的 Effect。

------

3. GAS 设计中“比较好”的点及对应实现

**面试官问：你认为 GAS 框架设计最精妙的地方在哪里？**

- **1. 逻辑与表现的高度解耦 (Gameplay Cue)：**
  - **实现：** 逻辑只管改属性加 Tag，表现层（特效/音效）只订阅 Tag 变化。
  - **优点：** 极大节省了带宽。不需要同步每个火球的每一个粒子，只需同步一个“火球碰撞”的 Tag，各端本地触发 GC。
- **2. 声明式的数据驱动 (Gameplay Effect)：**
  - **实现：** 通过简单的配置（Modifier、Execution）实现复杂的战斗公式，而不需要写冗余的代码。
  - **优点：** 方便策划调整平衡性，且 GE 的计算逻辑在底层是高度优化且经过严格同步验证的。
- **3. 异步任务处理 (Ability Task)：**
  - **实现：** 通过 `UAbilityTask` 实现“等待输入”、“等待延迟”、“等待碰撞”等异步逻辑。
  - **优点：** 避免了传统状态机中由于网络延迟导致的 `Tick` 轮询，使技能逻辑代码呈现流式（Streamline）结构，易于维护。
- **4. 灵活的预测支持 (Scoped Prediction Key)：**
  - **实现：** 允许开发者指定哪些逻辑可以被预测，哪些必须等待服务器。
  - **优点：** 在“强打击感（低延迟反馈）”和“数据安全性（防作弊）”之间达到了极佳的平衡。

------

面试加分点：弱网下的表现

**面试官问：弱网下 GAS 会有什么问题？**

- **回答：** 主要是**预测失效**后的表现。例如在极高延迟下，客户端预测释放了技能，但 500ms 后服务器返回“失败”，玩家会看到技能特效消失、属性值突跳。
- **优化建议：** 1. 针对核心技能做平滑插值（如果涉及数值）；2. 对于不可预测的行为（如随机抽奖），明确设置 `NonPredictive`。





2025.2
==============================================================


项目
Pong -- 实现了AI敌人，并引入“死区”变量，避免频繁抖动
Love2D，项目较小，主要用状态模式转换场景，包括菜单、地图场景、淡入淡出场景、战斗场景、结算场景、死亡场景等（以pokemon为例），
和Unity用Manager不同


自我介绍
各位面试官好，我是来自复旦大学软件工程专业的XXX。首先感谢莉莉丝能给我提供这次面试机会，

我在大学期间自学了哈佛大学CS50G的游戏开发课程，基于Love2D游戏框架，用Lua语言完成了若干个经典游戏demo的功能扩展作业，(所以我熟悉Lua语言，也了解Lua语言的面向对象实现);
其次，我用自学的Unity先后参加了两次Game Jam，
第一次是2024吉比特游戏举办的为时9天的高校挑战赛，比赛结束后我们把项目又进行了完善和扩展，总共开发了一个月，游戏是一个类《杀戮尖塔》的PVE回合制卡牌游戏，我在项目中负责所有UI的开发和Buff系统、场景加载和卡牌效果等游戏玩法相关的逻辑开发；在主程搭建的SO事件驱动框架的基础上我完善了UI更新事件的框架（避免SO配置过多而导致繁琐，而是一对多，一个BuffSO，多个BuffUI根据事件传递参数动态判断是否需要更新）； UI方面所有的动画都基于DoTween实现，我们使用Sprite和3D对象模拟UI而不是依赖Canvas导致频繁的重绘开销，所以我在项目中自己开发一套通用的Button和Panel接口（不仅实现了游戏全界面统一的交互逻辑，比如启用和禁用鼠标点击和动画效果，诸如淡入淡出，缩放等，而且适应了已有的SO事件系统），但也仍然使用了UGUI系统开发了一个可按不同标准排序的牌组滚动面板；在优化方面我使用了对象池技术来管理卡牌、伤害数字等大量实例化的对象（减轻GC压力），用Addressable资源管理系统优化场景加载和卡牌数据等的
第二次是2025 Global Game Jam，开发时长48小时，是一个气泡主题的2d平台跳跃闯关类游戏，我负责了游戏核心玩法机制以及游玩界面的UI开发，使用Unity动画系统实现玩家的动画状态机转换，用Unity粒子系统开发玩家移动和使用技能时喷出的气泡特效，在框架方面我们使用了基于C# EventHandler委托的泛型事件系统（采用单例模式提供Manager的全局访问点）；UI方面使用UGUI开发，并根据不同场景、模块分不同的Canvas和单独脚本管理，优化了DrawCall。
这是我最近两个项目经历的简单介绍；
以上就是我的自我介绍，谢谢！


开发经验
使用值类型（struct）作为事件参数以减少GC和装箱拆箱
如果使用SO处理Buff系统，那么每个敌人实例buff更新后需要调用SO Event来通知其UI更新，那么要创建大量的SO
SO事件驱动编程->观察者模式+单例模式 Manager统一管理,便于调试追踪
DiagramEffectsPanel自适应字数（一行一个sprite）没有拉伸，也没有使用滚动条



关键点解析
技术背景：突出C++基础（如智能指针、虚函数）、算法熟练度（LeetCode刷题经历）和Unity实操能力（项目细节），呼应中对技术栈的要求。
项目聚焦：选择最能体现Unity技术深度的项目，强调问题分析（如内存优化）和解决方案，避免泛泛而谈。
公司适配性：结合中面试官对UE/Unity技术栈的关注，可提及对莉莉丝游戏作品的理解，增强针对性。
表达规范：避免使用“精通”，转而用“熟练掌握”、“深入理解”等词，降低被追问的风险。
通过以上结构化表述，既能展现技术能力，又能体现对职位的匹配度，为后续技术问题和项目讨论奠定良好基础。


学过的课程：
大一上学期完成 Harvard CS50’s Introduction to Computer Science（CS50x 2023）课程学习及全部作业，使用C语言初步接触了数据结构与算法、SQL数据库和用Python Flask框架开发Web应用等；
大一寒假完成 Harvard CS50’s Introduction to Game Development（CS50G）课程学习及全部作业：基于Love2D框架使用Lua语言编写了经典游戏Pong、马里奥兄弟、塞尔达传说（2D）、宝可梦等核心逻辑，使用Unity引擎开发3D游戏 传送门等核心逻辑，初步接触并实现了游戏开发中碰撞、摄像机移动、关卡设计、关卡程序化生成、状态机、敌人AI、状态堆栈、物理引擎、RPG系统、GUI开发等核心模块（https://www.youtube.com/playlist?list=PLRH3e3WhmSh0byceJ5Nxj9c2JG9wM32qJ）；
大一下学期完成 CMU CS15213: CSAPP课程学习及所有Lab实现，理解了汇编语言、体系结构、操作系统、编译链接、并行、网络等计算机系统中核心部分，独立完成了Cache、Shell、动态内存分配器、代理服务器等的简易实现；
大一下学期完成 MIT 6.031: Software Construction课程学习，深入理解了软件工程中编写注释和函数 Specification，如何设计抽象数据结构以及诸多并行编程的内容等；
大一下学期在 FDU 软件工程专业核心课程 面向对象程序设计 Project中运用MVC和多种常用设计模式，使用JavaFx框架实现了一个简单的文字冒险游戏（https://www.bilibili.com/video/BV1q2waeUEHo/）；
大一暑假完成 Stanford CS106B Programming Abstractions课程学习及所有作业实现，包括简易的搜索引擎、基于哈夫曼树的文件压缩和解压缩程序等；
大二上学期在 数据结构 课程中独立完成了红黑树和B树的实现并应用于一个简单的英汉字典Demo，实现多种经典图论最短路/最小生成树算法并应用于一个简单的地图导航Demo，以上两个项目都使用了基于C++ SFML框架实现了自己的GUI库。
大二寒假完成GAMES101图形学入门课程学习及所有作业代码实现，学习并实现了图形学中光栅化、Blinn-Phong等着色模型、曲线曲面和光线追踪等部分。
PS：以上代码作业均提交在个人Github仓库。

个人优势：
多个游戏项目经历及个人作品（包含两次GameJam完整游戏Demo开发实战），对游戏开发流程有完整了解和掌握；
熟悉Unity引擎，有多次Unity项目开发经验；
熟悉C#、lua、C/C++、Java语言；
代码风格和编程习惯好，熟练掌握各种数据结构和算法；
熟练掌握MVC软件架构，熟悉软件开发中的各种设计模式，并能在日常开发中灵活运用；
对图形学有基本了解，能够理解基本的图形渲染技术；
热爱游戏，热爱游戏开发，喜欢玩游戏并且有自己的思考；
自驱力强，有强烈的自学能力；
逻辑思维能力好，学习能力优秀；
有责任感，有良好的沟通能力，具备团队合作精神；
英语好，能无障碍阅读英文文档。
具备良好的时间管理能力，能够高效执行任务，及时完成需求，确保项目按时交付。
能独立完成任务，积极发现问题、解决问题，不会等别人的催促或者别人来发现我的问题。


项目经历

1. 开发时间2024.11.22-2024.12.27  吉比特2024高校Gamejam挑战赛 项目名：梦醒两仪 （融合了道教八卦符咒元素的pve回合制卡牌游戏（类卡牌杀戮尖塔）），作为副程 负责所有UI开发和部分游戏逻辑开发：使用了UGUI系统开发了一套牌组预览滚动面板; 用自定义的Button和Panel系统和DoTween框架开发了一套可淡入淡出，动态效果统一的GUI；卡牌核心逻辑和伤害数字显示方面使用了对象池技术，优化了游戏性能；对卡牌属性和效果、敌人属性、八卦属性和效果等用ScriptableObject实现数据驱动，解耦了游戏代码结构，便利了游戏后续功能扩展；用Addressable资源管理系统优化了游戏场景加载性能；基于ScriptObject的事件框架实现全局订阅/触发松耦合（Demo视频链接：bilibili.com/video/BV1SkwYegEB1）

2. 开发时间2025.1.17-2025.1.19 GGJ China 2025
   制作了一个2D横板平台跳跃游戏，担任程序 负责核心游戏逻辑、音乐音效模块开发和部分UI开发 ： 使用Unity动画状态机完成角色八向移动动画转换；基于派发-监听模式的事件框架，使用EventManager全局管理事件以及所有Manager继承自自定义单例类，提供全局访问点的方式实现代码松耦合；使用Unity Particle System开发了角色移动时两种气泡粒子系统（游戏链接globalgamejam.org/games/2025/paolupaolu-0， Demo视频链接bilibili.com/video/BV1BCwaeDESJ）