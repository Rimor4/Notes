# LeetCode

## 哈希表

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

示例 1:

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // key: 排序后的字符串, value: 原始字符串集合
        unordered_map<string, vector<string>> mp;
        
        for (string& s : strs) {
            string t = s;
            sort(t.begin(), t.end()); // 排序作为哈希表的键
            mp[t].push_back(s);       // 将原词归类
        }
        
        vector<vector<string>> result;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            result.push_back(it->second);
        }
        
        return result;
    }
};

// 进阶版
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 自定义对 array<int, 26> 类型的哈希函数
        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
                return (acc << 1) ^ fn(num);
            });
        };

        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);
        for (string& str: strs) {
            array<int, 26> counts{};
            int length = str.length();
            for (int i = 0; i < length; ++i) {
                counts[str[i] - 'a'] ++;
            }
            mp[counts].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> numSet;
        for (int num : nums) {
            numSet.insert(num);
        }

        int maxStreak = 0;
        for (int num : numSet) {
            int curStreak = 1;
            // 只有当 num-1 不存在时，才说明 num 是一个连续序列的起点
            if (!numSet.contains(num - 1)) {
                while (numSet.contains(++num)) {
                    curStreak++;
                }
            }
            maxStreak = max(maxStreak, curStreak);
        }

        return maxStreak;
    }
};
```



## 双指针

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;
        int n = nums.size();
        
        // 类似**快排**中的分区逻辑
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                swap(nums[i], nums[j++]);
            }
        }
    }
};
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](D:\Projects\NOTES\images\rainwatertrap.png)

```cpp
class Solution {
public:
    // 核心原理：当前位水量 = min(左边最高, 右边最高) - 当前高度
    int trap(vector<int>& height) {
        int ans = 0;
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = max(leftMax, height[left]);
            rightMax = max(rightMax, height[right]);
            if (height[left] < height[right]) {
                // 左边较短，由于 rightMax 至少是 height[right]，所以我们确定对于左侧来说，右边的屏障一定足够高。
                // 此时限制水位的“短板”必然是 leftMax。
                ans += leftMax - height[left];
                ++left;
            } else {
                // 反之，如果右边较短，限制水位的“短板”必然是 rightMax
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
};
```



## 滑动窗口

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

```cpp
class Solution {
   public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans;
        int slen = s.length();
        int plen = p.length();

        if (slen < plen) {
            return vector<int>();
        }

        // windowBalance 记录 s 窗口内字母频率与 p 字母频率的差值。
        vector<int> windowBalance = vector<int>(26);
        for (int i = 0; i < plen; i++) {
            windowBalance[s[i] - 'a']++;
            windowBalance[p[i] - 'a']--;
        }

        // 用一个int变量代表 windowBalance 数组中非零元素的个数
        int mismatchCount = 0;
        for (int j = 0; j < 26; j++) {
            if (windowBalance[j] != 0) {
                mismatchCount++;
            }
        }

        if (mismatchCount == 0) {
            ans.push_back(0);
        }

        // 滑动过程，起始索引是i+1
        for (int i = 0; i < slen - plen; i++) {
            // 把左端滑出窗口，判断mismatchCount变化
            windowBalance[s[i] - 'a']--;
            if (windowBalance[s[i] - 'a'] == 0) {
                mismatchCount--;
            } else if (windowBalance[s[i] - 'a'] == -1) {
                mismatchCount++;
            }
            // 把右端滑入，判断mismatchCount变化
            windowBalance[s[i + plen] - 'a']++;
            if (windowBalance[s[i + plen] - 'a'] == 0) {
                mismatchCount--;
            } else if (windowBalance[s[i + plen] - 'a'] == 1) {
                mismatchCount++;
            }

            // 符合条件否
            if (mismatchCount == 0) {
                ans.push_back(i + 1);
            }
        }
        return ans;
    }
};
```



### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

给定一个二进制数组 `nums` 和一个整数 `k`，假设最多可以翻转 `k` 个 `0` ，则返回执行操作后 *数组中连续 `1` 的最大个数* 

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0;        // 窗口左边界
        int zeroCount = 0;   // 当前窗口内 0 的个数
        int maxLen = 0;      // 最大长度
        
        for (int right = 0; right < nums.size(); ++right) {
            if (nums[right] == 0) {
                zeroCount++;
            }
            
            // 如果窗口内 0 的个数超过了允许的 1 个
            while (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++; // 收缩左边界	
            }
            
            maxLen = max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
};
```







## 子串

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

```cpp
class Solution {
public:
    // 前缀和解决“连续子数组和”类问题
    int subarraySum(std::vector<int>& nums, int k) {
        // prefix-sum frequency map; mp[0]=1 for the empty prefix
        std::unordered_map<int, int> mp{{0, 1}};  
        int prefix = 0, count = 0;

        for (int num : nums) {
            prefix += num;                 // running prefix sum
            count  += mp[prefix - k];      // how many previous prefixes make (prefix-k)
            ++mp[prefix];                  // record current prefix
        }
        return count;
    }
};
```

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

```cpp
class Solution {
public:
    // 单调（递减）队列（不用map，前者O(n)后者O(nlogn)）
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> result;
        deque<int> indexDeque;			// 存索引
        
        auto push = [&](int i) {
            // 保持单调递减
            while (!indexDeque.empty() && nums[i] >= nums[indexDeque.back()]) {
                indexDeque.pop_back();
            }
            indexDeque.push_back(i);
        };
        
        for (int i = 0; i < n; ++i) {
            // 入队
            push(i);
            
            // 过期处理，检查队头元素是否已超出当前窗口范围
 			if (indexDeque.front() <= i - k) {
                indexDeque.pop_front();
            }
            
			// 只有窗口完整（达到 k 个元素）后才开始记录
            if (i >= k - 1) {
                result.push_back(nums[indexDeque.front()]);
            }
        }
        
        return result;
    }
};
```

### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给定两个字符串 `s` 和 `t`，长度分别是 `m` 和 `n`，返回 s 中的 **最短窗口 子串**，使得该子串包含 `t` 中的每一个字符（**包括重复字符**）。如果没有这样的子串，返回空字符串 `""`。

测试用例保证答案唯一。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

```cpp
class Solution {
public:
    // **贪心法**：先不断扩张窗口右侧，满足需求后再收缩窗口左侧（重点关注"Step-4"）
    std::string minWindow(const std::string& s, const std::string& t)
    {
        if (s.empty() || t.empty()) return "";

        std::unordered_map<char, int> need;
        for (char c : t) ++need[c];

        std::size_t needCnt = t.size();          // how many chars still missing
        std::size_t i = 0;                       // left boundary of window
        std::size_t bestL = 0, bestR = SIZE_MAX; // record the best window [bestL, bestR]

        for (std::size_t j = 0; j < s.size(); ++j)
        {
            char c = s[j];
            if (need[c] > 0)                      // this char is still needed
                --needCnt;
            --need[c];                            // put char c into current window

            // Step-1: the current window already covers all chars in t
            if (needCnt == 0)
            {
                // Step-2: shrink the left side as much as possible
                while (true)
                {
                    char leftChar = s[i];
                    if (need[leftChar] == 0)      // removing it would break the coverage
                        break;
                    ++need[leftChar];             // put the char back to "needed"
                    ++i;                          // move left boundary right
                }

                // Step-3: update the best window
                if (j - i < bestR - bestL)
                {
                    bestL = i;
                    bestR = j;
                }

                // **Step-4: move left boundary one step to look for a new window** (打破现状，寻找更优解)
                ++need[s[i]];
                ++needCnt;
                ++i;
            }
        }

        return bestR == SIZE_MAX ? "" : s.substr(bestL, bestR - bestL + 1);
    }
};
```

### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

```cpp
class Solution {
public:
    // KMP算法
    // 构建 Next 数组（前缀表）
    void getNext(vector<int>& next, const string& s) {
        int j = 0, n = s.size();
        next[0] = 0;
        // i 为后缀末尾， j 为前缀末尾
        for (int i = 1; i < n; i++) {
            while (j > 0 && s[i] != s[j]) {
                // 前后缀不相同
                // 回退
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                // 前后缀相同
                j++;
            }
            // 保存下来 前后缀最长相等长度
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        if (n < m) 
            return -1;
        if (m == 0) 
            return 0;

        vector<int> next(m);
        getNext(next, needle);

        int j = 0;
        for (int i = 0; i < n; i++) {
            while (j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == m) {
                return (i - m + 1);
            }
        }
        return -1;
    }
};
```



## 普通数组

### [238. 除了自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

```cpp
class Solution {
public:
    // 从左到右乘一遍，从右到左乘一遍
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();
        vector<int> answer(length);

        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }

        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }
        return answer;
    }
};
```



### [LCR 170. 逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```cpp
class Solution {
public:
    int reversePairs(vector<int>& record) {
        return mergeSort(record, 0, record.size() - 1);
    }

private:
    int mergeSort(vector<int>& vec, int l, int r) {
        if (l >= r)
            return 0;

        int mid = l + (r - l) / 2;
        int rev_cnt = 0;
        rev_cnt += mergeSort(vec, l, mid);
        rev_cnt += mergeSort(vec, mid + 1, r);
        rev_cnt += merge(vec, l, mid, r);

        return rev_cnt;
    }

    int merge(vector<int>& vec, int l, int mid, int r) {
        vector<int> tmp(r - l + 1);
        int i = l, j = mid + 1, k = 0;
        int rev = 0;

        // 在原先合并大循环中可以顺带统计逆序对数量
        while (i <= mid && j <= r) {
            if (vec[i] <= vec[j]) {
                tmp[k++] = vec[i++];
            } else {
                // vec[i] > vec[j]，产生逆序对
                rev += (mid - i + 1);	// XXX 左区间i后面的元素一定大于这个j，不用看了
                tmp[k++] = vec[j++];
            }
        }

        while (i <= mid)
            tmp[k++] = vec[i++];
        while (j <= r)
            tmp[k++] = vec[j++];

        for (int p = 0; p < tmp.size(); p++)
            vec[l + p] = tmp[p];

        return rev;
    }
};
```

### Hoare版本快速排序

```cpp
int partition(vector<int>& a, int l, int r) {
    int pivot = a[l];
    int i = l - 1;
    int j = r + 1;

    while (true) {
        do { ++i; } while (a[i] < pivot);
        do { --j; } while (a[j] > pivot);

        if (i >= j) return j;

        swap(a[i], a[j]);
    }
}

void quickSort(vector<int> &a, int l, int r) {
    if (l >= r) return;

    int p = partition(a, l, r);
    quickSort(a, l, p);
    quickSort(a, p + 1, r);
}
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        const int n = nums.size();

        // Step-1: 原地交换，让 nums[i] = i+1 尽可能成立
        for (int i = 0; i < n; ++i) {
            // while 而不是 if：把被换过来仍可继续交换的数也放到位
            // 条件解释：
            // 1. nums[i] 在 1..n 范围内
            // 2. 目标位置 nums[i] - 1 上不是同一个值（防止死循环）
            while (nums[i] >= 1 && nums[i] <= n &&
                   nums[nums[i] - 1] != nums[i]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }

        // Step-2: 找到第一个不匹配的位置
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) return i + 1;
        }
        return n + 1;
    }
};
```







## 矩阵

### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**

你能想出一个仅使用常量空间的解决方案吗？

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int rows = matrix.size();
        int cols = matrix[0].size();

        bool row0 = false, col0 = false;
        
        // 腾出第一行/列，用来存储所有待标记行/列
        // 1. 第一行/列本身是否需要置零
        for (int i = 0; i < cols; i++) {
            if (matrix[0][i] == 0) row0 = true;
        }
        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) col0 = true;
        }

        // 2. 第一遍扫，记录待标记行/列
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                } 
            }
        }

        // 3. 第二遍扫，进行实际的标记置零
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[0][j] == 0 || matrix[i][0] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 4. 处理首行首列
         if (row0) {
            for (int i = 0; i < cols; i++) {
                matrix[0][i] = 0;
            }
        }
        if (col0) {
            for (int i = 0; i < rows; i++) {
                matrix[i][0] = 0;
            }
        }
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。



**维护四个边界**

```cpp
class Solution {
   public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        if (matrix.empty()) return ans;  // 若数组为空，直接返回答案
        int u = 0;                       // 赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while (true) {
            for (int i = l; i <= r; ++i) ans.push_back(matrix[u][i]);  // 向右移动直到最右
            if (++u > d)
                break;  // 重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for (int i = u; i <= d; ++i) ans.push_back(matrix[i][r]);  // 向下
            if (--r < l) break;  // 重新设定有边界
            for (int i = r; i >= l; --i) ans.push_back(matrix[d][i]);  // 向左
            if (--d < u) break;  // 重新设定下边界
            for (int i = d; i >= u; --i) ans.push_back(matrix[i][l]);  // 向上
            if (++l > r) break;  // 重新设定左边界
        }
        return ans;
    }
};
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // 沿水平轴翻转
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                swap(matrix[n - i - 1][j], matrix[i][j]);
            }
        }

        // 沿主对角线翻转
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

<img src="D:\Projects\NOTES\images\image-20260115101315977.png" alt="image-20260115101315977" style="zoom:33%;" />

从**右上角**/左下角开始**Z字形**搜索

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int i = 0;
        int j = n - 1;

        while (i < m && j >= 0) {
            int curr = matrix[i][j];
            if (curr == target) {
                return true;
            } else if (curr < target) {
                i++;
            } else {
                j--;
            }
        }

        return false;
    }
};
```





## 链表

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

<img src="D:\Projects\NOTES\images\160_statement.png" alt="img" style="zoom: 50%;" />

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (headA == nullptr || headB == nullptr) {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        // 每一侧到头后换到另一侧。
        while (pA != pB) {
            pA = pA == nullptr ? headB : pA->next;
            pB = pB == nullptr ? headA : pB->next;
        }
        return pA;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* resHead = nullptr;
        ListNode* resPtr = nullptr;
        int carry = 0;
        while (l1 != nullptr || l2 != nullptr) {
            int n1 = 0;
            int n2 = 0;
            if (l1 != nullptr) {
                n1 = l1->val;
                l1 = l1->next;
            }
            if (l2 != nullptr) {
                n2 = l2->val;
                l2 = l2->next;
            }

            int sum = n1 + n2 + carry;
            carry = sum / 10;
            ListNode* node = new ListNode(sum % 10);
            if (resHead == nullptr) {
                resHead = node;
                resPtr = node;
            } else {
                resPtr->next = node;
                resPtr = resPtr->next;
            }
        }
        
        if (carry != 0) {
            ListNode* node = new ListNode(carry);
            resPtr->next = node;
        }

        return resHead;
    }
};
```

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

**节点拆分**

<img src="D:\Projects\NOTES\images\image-20260117085318460.png" alt="image-20260117085318460" style="zoom:50%;" />

```cpp
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        // 每个节点拆分为两个节点
        for (Node* node = head; node != nullptr; node = node->next->next) {
            Node* nodeNew = new Node(node->val);
            nodeNew->next = node->next;
            node->next = nodeNew;
        }
        // 给新节点的random指针赋值
        for (Node* node = head; node != nullptr; node = node->next->next) {
            Node* nodeNew = node->next;
            nodeNew->random = (node->random != nullptr) ? node->random->next : nullptr;
        }
        // 将新节点从链表中chai'cu
        Node* headNew = head->next;
        for (Node* node = head; node != nullptr; node = node->next) {
            Node* nodeNew = node->next;
            node->next = node->next->next;
            nodeNew->next = (nodeNew->next != nullptr) ? nodeNew->next->next : nullptr;
        }
        return headNew;
    }
};
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) { return sortList(head, nullptr); }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if (head == nullptr) {
            return head;
        }
        
        // XXX: 链表只有一个节点：断开连接，使其成为独立的子链表(方便之后merge函数中可以通过 nullptr 判断哪里是结尾)
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }
        
        // 用快慢指针技巧找到中点
        ListNode *slow = head, *fast = head;
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    }

    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode dummy(0);	// 栈上分配局部对象，来避免内存泄漏和频繁的堆分配
        ListNode *temp = &dummy, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        }
        if (temp2 != nullptr) {
            temp->next = temp2;
        }

        return dummy.next;
    }
};
```

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

#### 分治法

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode dummy(0);
        ListNode* temp = &dummy, *temp1 = a, *temp2 = b;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val < temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            } else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        if (temp1 != nullptr) {
            temp->next = temp1;
        }
        if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummy.next;
    }

    ListNode* merge(vector<ListNode*>& lists, int l, int r) {
        if (l > r) return nullptr;
        if (l == r) return lists[l];
        int mid = l + (r - l) / 2;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```

#### 优先队列法

```cpp
class Solution {
public:
    struct QueueNode {
        int val;
        ListNode* ptr;
        bool operator>(const QueueNode& rhs) const { 
            // 如果你定义 a > b 为真，那么 a 就会被排在 b 的前面（即 a 的优先级更高）
            return val < rhs.val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<QueueNode> que;
        for (auto node : lists) {
            if (node) {
                que.push({node->val, node});
            }
        }

        ListNode dummy, *temp = &dummy;
        while (!que.empty()) {
            auto cur = que.top();
            que.pop();

            temp->next = cur.ptr;
            temp = temp->next;

            ListNode* nextLinkNode = cur.ptr->next;
            if (nextLinkNode) {
                que.push({nextLinkNode->val, nextLinkNode});
            }
        }

        return dummy.next;
    }
};
```







## 二叉树

### 非递归版前中后遍历

```cpp
vector<int> preorderTraversal(TreeNode* root) {
    if (!root) return {};
    vector<int> res;
    stack<TreeNode*> st;
    st.push(root);

    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        res.push_back(node->val); // 访问中节点

        // 先压右再压左，弹出时就是先左后右
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
    return res;
}

vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    TreeNode* curr = root;

    while (curr != nullptr || !st.empty()) {
        // 1. 尽可能向左走，路径上的节点全部入栈
        while (curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }
        // 2. 弹出栈顶并访问（此时它是最左的）
        curr = st.top();
        st.pop();
        res.push_back(curr->val);
        
        // 3. 转向右子树
        curr = curr->right;
    }
    return res;
}

vector<int> postorderTraversal(TreeNode* root) {
    if (!root) return {};
    vector<int> res;
    stack<TreeNode*> st;
    st.push(root);

    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        res.push_back(node->val);

        // 注意：这里先压左再压右，弹出顺序就是中-右-左
        if (node->left) st.push(node->left);
        if (node->right) st.push(node->right);
    }
    
    reverse(res.begin(), res.end()); // 反转得到左-右-中
    return res;
}
```



## 图论

### Dijkstra算法

```cpp
std::vector<int> dijkstra(int n, int src, std::vector<std::vector<std::pair<int, int>>>& graph) {
    std::vector<int> dist(n, std::numeric_limits<int>::max());
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> pq; // greater从小到大(先比较first，若相等，比较second)
    dist[src] = 0;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();

        if (dist[u] < d) continue;

        for (auto &[v, w] : graph[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

    return dist;
}
```

### A*算法

```cpp
struct Node {
    int v, g, f;    // g 是已知事实（从起点走过来的真实代价）；f = g + h 是搜索策略（对“通过该点到终点”的估计）
    bool operator>(const Node& other) {
        return f > other.f;
    }
};

std::vector<int> astar(int n, int src, int goal, std::vector<std::vector<std::pair<int, int>>>& graph, std::function<int(int)> heuristic) {
    std::vector<int> g(n, std::numeric_limits<int>::max());
    std::vector<int> parent(n, -1);
    std::vector<bool> closed(n, false);
    std::priority_queue<Node, std::vector<Node>, std::greater<>> open;

    g[src] = 0;
    open.push({src, 0, heuristic(src)});

    while (!open.empty()) {
        Node cur = open.top();
        open.pop();

        int u = cur.v;
        if (closed[u]) continue;
        closed[u] = true;

        for (auto& [v, w] : graph[u]) {
            int newG = w + g[u];
            if (newG < g[v]) {
                g[v] = newG;
                parent[v] = u;
                open.push({v, newG, newG + heuristic(v)});
            }
        }
    }

    std::vector<int> path;
    if (g[goal] == std::numeric_limits<int>::max()) return path;    // 没有到达goal

    for (int v = goal; v != -1; v = parent[v])
        path.push_back(v);
    std::reverse(path.begin(), path.end());

    return path;
}
```





## 回溯



## 二分查找



## 堆



## 栈

### 中缀表达式转后缀表达式

利用栈来暂存运算符，直到遇到优先级更低的运算符或右括号时才将其输出。![image-20260113201926289](D:\Projects\NOTES\images\image-20260113201926289.png)





## 贪心

### [179. 最大数](https://leetcode.cn/problems/largest-number/)

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

```cpp
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> strs;
        // 1. 将所有数字转为字符串
        for (int num : nums) {
            strs.push_back(to_string(num));
        }

        // 2. 自定义排序规则
        sort(strs.begin(), strs.end(), [](const string& a, const string& b) {
            // 比较拼接结果：a+b 和 b+a
            return a + b > b + a; 
        });

        // 3. 特殊情况处理：如果排序后第一个数是 "0"，说明整个数组全是 0
        if (strs[0] == "0") {
            return "0";
        }

        // 4. 拼接结果
        string res = "";
        for (const string& s : strs) {
            res += s;
        }

        return res;
    }
};
```



### **给定一根横轴，上面随机分布着n个点，每个点的位置、速度是随机的，但是点的方向只能向左或者向右，如果两个点相遇就会碰撞消失，假设有解的情况下，求最后一对点碰撞消失的时间是多少？**

贪心，从左到右用栈配对（类似括号匹配）





## 动态规划

### 有1、3、5元三种硬币，问组成m元有多少种方法

重点在外层循环先遍历coins，内层循环才遍历金额。（防止有{1, 3} {3, 1} 这样的同时出现）

```cpp
long long change(int m) {
    // 1. 定义 dp 数组，m + 1 是为了包含金额 m
    // 使用 long long 防止金额较大时方法数溢出
    vector<long long> dp(m + 1, 0);
    
    // 2. 初始化：凑成 0 元的方法只有 1 种
    dp[0] = 1;
    
    // 3. 硬币面额
    vector<int> coins = {1, 3, 5};
    
    // 4. 先遍历硬币，再遍历金额（确保组合唯一性）
    for (int coin : coins) {
        for (int i = coin; i <= m; ++i) {
            // 当前方法数 = 原有方法数 + 凑出(当前金额 - 硬币面值)的方法数
            dp[i] += dp[i - coin];
        }
    }
    
    return dp[m];
}
```

### 炸弹人

**给一张图，有敌人、墙、空地，炸弹能放在空地上，炸该行该列没被墙挡住的敌人，问给一个炸弹最多能炸多少敌人？**

```cpp
int maxKilledEnemies(vector<vector<char>>& grid) {
    if (grid.empty() || grid[0].empty()) return 0;
    int m = grid.size(), n = grid[0].size();
    int maxEnemies = 0;
    int rowCount = 0;
    vector<int> colCount(n, 0);

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            // 1. 处理行：只有在行首或者前一个是墙时，才重新计算当前连续区间的敌人
            if (j == 0 || grid[i][j - 1] == 'W') {
                rowCount = 0;
                for (int k = j; k < n && grid[i][k] != 'W'; ++k) {
                    if (grid[i][k] == 'E') rowCount++;
                }
            }
            // 2. 处理列：只有在行首或者上一个是墙时，才重新计算当前垂直区间的敌人
            if (i == 0 || grid[i - 1][j] == 'W') {
                colCount[j] = 0;
                for (int k = i; k < m && grid[k][j] != 'W'; ++k) {
                    if (grid[k][j] == 'E') colCount[j]++;
                }
            }
            // 3. 如果是空地，尝试放置炸弹并更新最大值
            if (grid[i][j] == '0') {
                maxEnemies = max(maxEnemies, rowCount + colCount[j]);
            }
        }
    }
    return maxEnemies;
}
```



## 多维动态规划



## 技巧

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int p0 = 0;              // 指向 0 的右边界
        int curr = 0;            // 当前处理的元素
        int p2 = nums.size() - 1; // 指向 2 的左边界

        while (curr <= p2) {
            if (nums[curr] == 0) {
                // 发现 0，换到左边，p0 和 curr 同时右移
                swap(nums[curr], nums[p0]);
                p0++;
                curr++;
            } 
            else if (nums[curr] == 2) {
                // 发现 2，换到右边。
                // 注意：换回来的数还没看过，所以 curr 不能移动
                swap(nums[curr], nums[p2]);
                p2--;
            } 
            else {
                // 发现 1，已经在中间区域，直接跳过
                curr++;
            }
        }
    }
};
```

### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**异或法**

### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

**Boyer-Moore 投票算法**

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                // 票数减 1 模拟抵消。如果 count 减完后小于 0，
        		// 说明之前的候选人被完全抵消了，需要更换新的候选人。
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        // 从右向左找到一个“较小数”使该数右边是降序排列“p”
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            // 在降序排列中找到一个尽可能小的“较（相对较小数而言）大数”
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            // 只用一次swap可得到的尽可能小的比nums大的排列，
            swap(nums[i], nums[j]);
        }
        // （交换后）再反转降序排列“p”，“p”部分的数最小（升序最小）
        reverse(nums.begin() + i + 1, nums.end());
    } 
    // 1 2 7 6 5
    //     |
    // 1 5 2 6 7
};
```

### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

```cpp
class Solution {
public:
    // Floyd 判环算法
    // 转化为 链表中寻找环的入口 的问题
    // 把 nums[i] 看作是从 i 到 nums[i] 的一条「边」
    // nums = [1, 3, 4, 2, 2]
    // 画出如下映射：
    // 0 → 1
    // 1 → 3
    // 2 → 4
    // 3 → 2
    // 4 → 2
    // 至少有两个索引指向同一个值，形成一个环
    int findDuplicate(vector<int> &nums) {
        // 阶段 1：快慢指针找相遇点
        int slow = nums[0];
        int fast = nums[nums[0]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        // 阶段 2：找环入口（重复数）
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```





### 有n个硬币，已知一个是轻的，给我一个天平，最少多少次找到

核心思路：**三分法**

每一次称重，天平都有三种可能的结果：

1. **左边轻**：假币在左边的堆里。
2. **右边轻**：假币在右边的堆里。
3. **平衡**：假币在没上天平的那一堆里。

为了让每次称重发挥最大效率，我们应该将硬币尽可能均匀地分为 **3 堆**。

【举例(n = 8)：
将 8 个硬币分为 (3, 3, 2)。称量两个 3。

- 如果平衡：假币在剩下的 2 个里。
- 如果不平衡：假币在轻的那 3 个里。】

```cpp
// 直接算log以3为底n的对数
int minWeighingTimesMath(int n) {
    if (n <= 1) return 0;
    // log(n)/log(3) 换底公式实现 log3(n)
    return ceil(log(n) / log(3));
}
```





## 情景

### 守护者

**一维坐标轴上动态维护区间**的问题

![image-20260113171403093](D:\Projects\NOTES\images\image-20260113171403093.png)

```cpp
#include <iostream>
#include <set>
#include <map>

using namespace std;

typedef long long ll;

ll N; // 数组长度

// 定义空闲区间结构体
struct Segment {
    ll l, r;
    ll dist, pos;

    Segment(ll _l, ll _r) : l(_l), r(_r) {
        if (l == 0 && r == N + 1) {
            // 特殊处理：数组完全为空时，根据题意放到位置 1
            dist = 2e18; // 设置一个极大的距离确保优先级最高
            pos = 1;
        } else if (l == 0) {
            // 左边界情况
            dist = r - 1;
            pos = 1;
        } else if (r == N + 1) {
            // 右边界情况
            dist = N - l;
            pos = N;
        } else {
            // 中间情况：取中点
            dist = (r - l) / 2;
            pos = l + dist;
        }
    }

    // 定义排序规则：距离大优先；坐标小优先
    bool operator<(const Segment& other) const {
        if (dist != other.dist) return dist > other.dist;
        return l < other.l;
    }
};

set<Segment> segments;      // 存储所有空闲区间
set<ll> positions;          // 存储所有已占用的坐标（含虚拟边界 0 和 N+1）
map<int, ll> id_to_pos;     // 存储守护者 ID 到坐标的映射

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int m;
    if (!(cin >> N >> m)) return 0;

    // 初始化：放入虚拟边界
    positions.insert(0);
    positions.insert(N + 1);
    segments.insert(Segment(0, N + 1));

    while (m--) {
        int type, id;
        cin >> type >> id;

        if (type == 1) {
            // 放入守护者
            if (id_to_pos.count(id)) continue; // 已存在则忽略
            
            Segment best = *segments.begin();
            // 如果最优位置已被占用，说明没地方放了
            if (positions.count(best.pos)) continue;

            cout << best.pos << "\n";
            
            ll p = best.pos;
            ll l = best.l;
            ll r = best.r;

            id_to_pos[id] = p;
            segments.erase(segments.begin());
            
            // 分裂区间并更新
            segments.insert(Segment(l, p));
            segments.insert(Segment(p, r));
            positions.insert(p);
        } 
        else if (type == 2) {
            // 取出守护者
            if (!id_to_pos.count(id)) continue; // 不存在则忽略

            ll p = id_to_pos[id];
            cout << p << "\n";

            auto it = positions.find(p);
            ll l = *prev(it);
            ll r = *next(it);

            // 合并区间并更新
            segments.erase(Segment(l, p));
            segments.erase(Segment(p, r));
            segments.insert(Segment(l, r));

            positions.erase(it);
            id_to_pos.erase(id);
        }
    }

    return 0;
}
```

### 龙化前的冲刺

<img src="D:\Projects\NOTES\images\image-20260113184550064.png" alt="image-20260113184550064" style="zoom:67%;" />

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

struct Point {
    double x, y;
};

// 计算平方距离，避免频繁使用 sqrt 提高效率
double get_dist_sq(Point a, Point b) {
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

int main() {
    int n, e, p;
    double r1, r2;
    if (!(cin >> n >> e >> p >> r1 >> r2)) return 0;

    vector<Point> pts(n);
    for (int i = 0; i < n; i++) cin >> pts[i].x >> pts[i].y;

    double r1_sq = r1 * r1;
    double r2_sq = r2 * r2;

    // 预计算所有灯塔间的平方距离
    vector<vector<double>> adj_dist_sq(n, vector<double>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            adj_dist_sq[i][j] = get_dist_sq(pts[i], pts[j]);
        }
    }

    // 情况 0: 完全不使用特殊药水
    auto solve0 = [&]() -> int {
        vector<int> dist(n, -1);
        queue<int> q;
        q.push(0);
        dist[0] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            if (u == n - 1) return dist[u];
            for (int v = 0; v < n; v++) {
                if (dist[v] == -1 && adj_dist_sq[u][v] <= r1_sq) {
                    dist[v] = dist[u] + 1;
                    q.push(v);
                }
            }
        }
        return -1;
    };

    int res0 = solve0();
    if (res0 != -1 && res0 <= e) {
        cout << "0 " << res0 << endl;
        return 0;
    }

    // 情况 1: 使用一次特殊药水
    // 状态 dist[灯塔][k]
    // k=0: 未用, k=1..p: 正在用第k次, k=p+1: 已用完
    auto solve1 = [&]() -> int {
        vector<vector<int>> dist(n, vector<int>(p + 2, -1));
        struct State { int u, k; };	// (灯塔编号，药水状态)
        queue<State> q;

        dist[0][0] = 0;
        q.push({0, 0});

        while (!q.empty()) {
            State curr = q.front(); q.pop();
            int u = curr.u;
            int k = curr.k;
            int d = dist[u][k];

            if (u == n - 1) return d;
            if (d >= e) continue; // 药水不足，不再扩展

            for (int v = 0; v < n; v++) {
                double d2 = adj_dist_sq[u][v];
                if (k == 0) {
                    // 1. 继续不使用特殊药水
                    if (d2 <= r1_sq && dist[v][0] == -1) {
                        dist[v][0] = d + 1;
                        q.push({v, 0});
                    }
                    // 2. 此时此刻开启特殊药水
                    int next_k = (p == 1) ? p + 1 : 1;
                    if (d2 <= r2_sq && dist[v][next_k] == -1) {
                        dist[v][next_k] = d + 1;
                        q.push({v, next_k});
                    }
                } else if (k >= 1 && k < p) {
                    // 必须消耗特殊药水的次数 (使用r2范围)
                    int next_k = (k + 1 == p) ? p + 1 : k + 1;
                    if (d2 <= r2_sq && dist[v][next_k] == -1) {
                        dist[v][next_k] = d + 1;
                        q.push({v, next_k});
                    }
                } else if (k == p + 1) {
                    // 药水已耗尽，回归 r1 范围
                    if (d2 <= r1_sq && dist[v][p + 1] == -1) {
                        dist[v][p + 1] = d + 1;
                        q.push({v, p + 1});
                    }
                }
            }
        }
        return -1;
    };

    int res1 = solve1();
    if (res1 != -1 && res1 <= e) {
        cout << "1 " << res1 << endl;
    } else {
        cout << "-1 -1" << endl;
    }

    return 0;
}
```



















































