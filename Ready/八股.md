## C++

### Rule of Five？

如果你编写的类需要手动管理资源（如原始指针、文件句柄、网络连接等），你通常需要同时显式定义 **5 个** 特殊成员函数。

```cpp
class ResourceManager {
    int* data;
    size_t size;

public:
    // 1. 析构函数 (Destructor) - 释放资源
    ~ResourceManager() {
        delete[] data;
    }

    // 2. 拷贝构造函数 (Copy Constructor) - 深拷贝
    ResourceManager(const ResourceManager& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // 3. 拷贝赋值运算符 (Copy Assignment) - 释放旧资源，拷贝新资源
    ResourceManager& operator=(const ResourceManager& other) {
        if (this != &other) {
            delete[] data; // 释放旧的
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }

    // 4. 移动构造函数 (Move Constructor) - 窃取资源，原对象置空
    ResourceManager(ResourceManager&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr; // 关键：防止原对象析构时释放这块内存
        other.size = 0;
    }

    // 5. 移动赋值运算符 (Move Assignment) - 释放旧资源，窃取新资源
    ResourceManager& operator=(ResourceManager&& other) noexcept {
        if (this != &other) {
            delete[] data;      // 释放自己的
            data = other.data;  // 拿走别人的
            size = other.size;
            other.data = nullptr; // 别人置空
            other.size = 0;
        }
        return *this;
    }
};
```



### 智能指针实现！

```cpp
#include <atomic>
#include <utility>

// 前置声明
template <typename T> class SharedPtr;
template <typename T> class WeakPtr;
template <typename T> class enable_shared_from_this;

// 1. 基础控制块：负责引用计数
struct Counter {
    std::atomic<int> shared_cnt;
    std::atomic<int> weak_cnt;

    Counter() : shared_cnt(1), weak_cnt(0) {}
    virtual ~Counter() {}

    // 纯虚函数：不同的子类决定如何释放对象
    virtual void dispose() = 0; 
    
    // 释放自身（控制块）内存
    virtual void destroy() {
        delete this;
    }
};

// 2. 指针控制块：用于 SharedPtr(T* p)
// 这种情况下，对象内存和控制块内存是分开的
template <typename T>
struct PtrControlBlock : public Counter {
    T* ptr; // 保存指针以便删除

    PtrControlBlock(T* p) : ptr(p) {}

    void dispose() override {
        delete ptr; // 普通指针直接 delete
    }
};

// 3. 连续内存控制块：用于 make_shared
// 对象直接存放在控制块内部
template <typename T>
struct BlockControlBlock : public Counter {
    alignas(T) char data[sizeof(T)];

    template <typename... Args>
    BlockControlBlock(Args &&...args) : Counter() {
        new (data) T(std::forward<Args>(args)...);
    }

    void dispose() override {
        // 只调用析构函数，不 delete 指针，因为内存是控制块的一部分
        reinterpret_cast<T*>(data)->~T(); 
    }
    
    // 只有当 weak_cnt 也为 0 时，才整个 delete 掉 BlockControlBlock
};

// ================= SharedPtr 实现 =================

template <typename T>
class SharedPtr {
public:
    // 默认构造
    SharedPtr() : ptr(nullptr), counter(nullptr) {}
    
    // 空指针构造
    SharedPtr(std::nullptr_t) : ptr(nullptr), counter(nullptr) {}

    // 裸指针构造 (注意：这里创建的是 PtrControlBlock)
    explicit SharedPtr(T *p) : ptr(p) {
        if (p) {
            counter = new PtrControlBlock<T>(p);
            enable_shared_from_this_helper(p, p);
        }
    }

    // 析构
    ~SharedPtr() {
        release();
    }

    // 拷贝构造
    SharedPtr(const SharedPtr<T> &other) : ptr(other.ptr), counter(other.counter) {
        if (counter) counter->shared_cnt++;
    }

    // 拷贝赋值
    SharedPtr &operator=(const SharedPtr<T> &other) {
        if (this != &other) {
            release();
            ptr = other.ptr;
            counter = other.counter;
            if (counter) counter->shared_cnt++;
        }
        return *this;
    }

    // 移动构造
    SharedPtr(SharedPtr<T> &&other) noexcept : ptr(other.ptr), counter(other.counter) {
        other.ptr = nullptr;
        other.counter = nullptr;
    }

    // 移动赋值
    SharedPtr &operator=(SharedPtr<T> &&other) noexcept {
        if (this != &other) {
            release();
            ptr = other.ptr;
            counter = other.counter;
            other.ptr = nullptr;
            other.counter = nullptr;
        }
        return *this;
    }
    
    // 从 WeakPtr 构造 (为了 lock)
    explicit SharedPtr(const WeakPtr<T>& weak) : ptr(nullptr), counter(nullptr) {
        // 需要访问 weak 的私有成员，已经在 WeakPtr 中声明 friend
        if (weak.counter && weak.counter->shared_cnt > 0) {
            counter = weak.counter;
            ptr = weak.ptr;
            counter->shared_cnt++;
        }
    }

    T &operator*() const { return *ptr; }
    T *operator->() const { return ptr; }
    T *get() const { return ptr; }
    long use_count() const { return counter ? counter->shared_cnt.load() : 0; }

private:
    T *ptr = nullptr;
    Counter *counter = nullptr;

    // 私有构造：供 make_shared 使用
    SharedPtr(T *p, Counter* c) : ptr(p), counter(c) {
        enable_shared_from_this_helper(p, p);
    }
    
    // 专门为 make_shared 准备的友元函数需要特殊处理引用计数
    template <typename U, typename... Args>
    friend SharedPtr<U> make_shared(Args &&...args);

    friend class WeakPtr<T>;

    void release() {
        if (!counter) return;

        // 1. 减少共享引用计数
        if (--counter->shared_cnt == 0) {
            // 2. 只有当引用计数为0，才销毁对象 (调用 dispose 虚函数)
            // 注意：此时不能 delete counter，因为 weak_cnt 可能不为 0
            counter->dispose(); 

            // 3. 如果弱引用也是0，才释放控制块内存
            if (counter->weak_cnt == 0) {
                counter->destroy();
            }
        }
        
        ptr = nullptr;
        counter = nullptr;
    }

    // enable_shared_from_this SFINAE 辅助函数
    template<typename U>
    void enable_shared_from_this_helper(enable_shared_from_this<U>* es, U* p) {
        es->weak_this = *this;
    }
    
    void enable_shared_from_this_helper(...) {} // 对于没有继承 enable_shared_from_this 的类，什么都不做
};

// ================= WeakPtr 实现 =================

template <typename T>
class WeakPtr {
public:
    WeakPtr() = default;

    WeakPtr(const SharedPtr<T> &sptr) : ptr(sptr.ptr), counter(sptr.counter) {
        if (counter) counter->weak_cnt++;
    }

    WeakPtr(const WeakPtr &other) : ptr(other.ptr), counter(other.counter) {
        if (counter) counter->weak_cnt++;
    }

    WeakPtr &operator=(const WeakPtr &other) {
        if (this != &other) {
            release();
            ptr = other.ptr;
            counter = other.counter;
            if (counter) counter->weak_cnt++;
        }
        return *this;
    }
    
    // 允许从 SharedPtr 赋值
    WeakPtr &operator=(const SharedPtr<T> &sptr) {
        release();
        ptr = sptr.ptr;
        counter = sptr.counter;
        if (counter) counter->weak_cnt++;
        return *this;
    }

    WeakPtr(WeakPtr &&other) noexcept : ptr(other.ptr), counter(other.counter) {
        other.ptr = nullptr;
        other.counter = nullptr;
    }

    WeakPtr &operator=(WeakPtr &&other) noexcept {
        if (this != &other) {
            release();
            ptr = other.ptr;
            counter = other.counter;
            other.ptr = nullptr;
            other.counter = nullptr;
        }
        return *this;
    }

    ~WeakPtr() {
        release();
    }

    bool expired() const {
        return !counter || counter->shared_cnt == 0;
    }

    // 修复：必须返回对象，不能返回引用
    SharedPtr<T> lock() const {
        return SharedPtr<T>(*this);
    }

private:
    T *ptr = nullptr;
    Counter *counter = nullptr;

    friend class SharedPtr<T>;
    friend class enable_shared_from_this<T>; // 让 enable_shared_from_this 访问

    void release() {
        if (!counter) return;

        // 弱引用只负责释放 ControlBlock 本身
        if (--counter->weak_cnt == 0 && counter->shared_cnt == 0) {
            counter->destroy();
        }
        counter = nullptr;
        ptr = nullptr;
    }
};

// ================= make_shared 实现 =================

template <typename T, typename... Args>
SharedPtr<T> make_shared(Args &&...args) {
    // 1. 创建连续内存块
    auto *cb = new BlockControlBlock<T>(std::forward<Args>(args)...);
    
    // 2. 获取对象指针
    T *ptr = reinterpret_cast<T *>(cb->data);
    
    // 3. 构造 SharedPtr
    return SharedPtr<T>(ptr, cb);
}

// ================= enable_shared_from_this 实现 =================

template <typename T>
class enable_shared_from_this {
public:
    SharedPtr<T> shared_from_this() {
        // 通过 weak_this 构造 shared_ptr
        return weak_this.lock(); 
    }

protected:
    enable_shared_from_this() = default;
    ~enable_shared_from_this() = default;

    mutable WeakPtr<T> weak_this;

    // 友元声明
    template<typename U> friend class SharedPtr;
};
```



### 编译器处理虚函数表？

 对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤： 

-  拷贝基类的虚函数表。如果是多继承，就**拷贝**每个有虚函数的基类的虚函数表（其中**主基类**的虚函数表被放在派生类对象内存布局的起始位置 ，派生类对象的第一个 vptr 指向的就是这张表）
- 查看派生类中是否有重写基类中的虚函数， 如果有，就**替换**成已经重写的虚函数地址；
- 查看派生类是否有自身的虚函数，如果有，就**追加**自身的虚函数到自身的虚函数表中。<img src="D:\Projects\NOTES\images\image-20260102224712731.png" alt="image-20260102224712731" style="zoom: 50%;" />

### dynamic_cast是怎么实现的？

dynamic_cast 属于 RTTI, 运行时类型识别的一个内容。主要内容是 **typeid** 与 **typeinfo** 的实现, 基本思路就是在有虚函数的类的虚表的头部位置存放 RTTI 的相关信息。在 VC 里面可以看到是一个叫做 RTTI Complete Object Locator 的结构体里面存放相关的信息。在强转的时候，会读取里面对应的类的信息进而判断是否能转换成功。

![img](D:\Projects\NOTES\images\v2-29ff744ae7eaf85424dd7f167fc15abf_r.jpg)



### Lambda 表达式在编译器层的实现?

Lambda 表达式在编译器层面的实现本质上是一个**匿名的仿函数（Functor）类**

编译器会为每个 Lambda 表达式自动生成一个唯一的结构体（或类），并重载其 `operator()` 运算符。

在运行到 Lambda 定义处时，编译器会实例化这个结构体，这个实例化的对象就是所谓的‘**闭包’**



### memmove和memcpy对比?

**`memcpy` (Memory Copy)**：假设源内存区域（src）和目标内存区域（dest）**没有重叠**。如果发生重叠，其行为是**未定义**的（通常会导致数据被覆盖污染）。

**`memmove` (Memory Move)**：允许源区域和目标区域**重叠**。它保证拷贝后的结果就像先将数据拷贝到一个临时缓冲区，然后再从缓冲区拷贝到目标位置一样。



**优化**：使用CPU字长来copy

```cpp
void *memcpy(void *pDest,const void *pSrc,size_t n)
{
    assert((pDest != NULL) && (pSrc != NULL));
    int wordnum = n / 4;            // 计算有多少个32位，按4字节拷贝
    int slice = n % 4;              // 剩余的按字节拷贝
    int* pIntsrc = (int*)pSrc;
    int* pIntdest = (int*)pDest;

    while(wordnum--)
        *pIntdest++ = *pIntsrc++;
    while (slice--)
        *((char*)pIntdest++) = *((char*)pIntsrc++);

    return pDest;
}
```



### 在nullptr上调用成员函数/虚函数

| **情况**                        | **结果**     | **原因**                                         |
| ------------------------------- | ------------ | ------------------------------------------------ |
| **普通成员函数 (无数据访问)**   | **成功输出** | 函数地址在编译期确定，不解引用 `this` 即可。     |
| **普通成员函数 (访问成员变量)** | **程序崩溃** | 尝试对 `0` 地址进行偏移访问。                    |
| **虚函数 (virtual)**            | **直接崩溃** | 必须解引用 `this` 才能找到虚函数表 (`vtable`)。  |
| **静态成员函数 (static)**       | **成功输出** | 静态函数不依赖 `this` 指针，跟指针是否为空无关。 |



## UE

### 反射？

1. 核心宏标记：信息的入口

开发者通过在代码中加入特殊的宏（如 `UCLASS`, `UPROPERTY`, `UFUNCTION`）来标记需要反射的内容。这些宏在标准 C++ 编译时会被忽略（定义为空），但它们是给 **Unreal Header Tool (UHT)** 看的“路标”。

2. 预编译阶段：UHT 的魔力

这是 UE 反射最关键的一步。在真正的 C++ 编译器（如 MSVC, Clang）介入之前，UE 会先运行 **UHT (Unreal Header Tool)**。

1. **扫描 (Scanning)：** UHT 扫描所有包含 `.h` 的头文件，寻找 `UCLASS` 等宏。
2. **解析 (Parsing)：** UHT 解析类名、继承关系、变量名、类型及元数据（如 `Category`, `BlueprintReadOnly`）。
3. **生成代码 (Code Generation)：** UHT 为每个头文件生成一个 `.gen.cpp` 文件。
   - 这些文件里包含了大量的静态初始化代码。
   - 它们会创建对应的 `UClass`、`FProperty`、`UFunction` 对象，并把这些信息注册到全局数据库中。
   - `GENERATED_BODY()` 宏会被展开，用于在类内部注入反射所需的存取辅助函数。

3.  注册过程：反射数据的组装

   当程序启动时，这些生成的 `.gen.cpp` 文件利用 C++ 静态变量初始化的特性，将反射元数据注册到全局的 **GUObjectArray** 中。

   - **构造 UClass 对象：** 系统为每个类创建一个 `UClass` 实例，它就像是一个“蓝图”。
   - **构建属性链表：** 通过内存偏移量记录每个 `UPROPERTY` 在类实例中的相对位置。这样，只要知道类实例的起始地址，加上偏移量，就能直接访问变量，而无需知道变量名。

4. 运行时：元数据对象模型

   UE 将反射信息存储在一套以 `UField` 为基类的对象层级结构中。

   - **UClass：** 描述一个类的所有信息（父类、函数列表、属性列表）。
   - **FProperty (旧版为 UProperty)：** 描述变量的类型、内存偏移量（Offset）、数组长度等。
   - **UFunction：** 描述函数的签名、参数类型、返回值以及指向函数体的指针。

5. 核心应用场景

   #### A. 编辑器与蓝图 (Editor & Blueprint)

   编辑器通过遍历 `UClass` 下的 `FProperty` 列表，自动生成“细节（Details）”面板。蓝图系统则通过 `UFunction` 的元数据动态调用 C++ 函数。

   #### B. 序列化 (Serialization)

   当你要把一个 Actor 保存到存档或从磁盘加载时，UE 遍历反射数据，找到所有标记为 `UPROPERTY` 的变量，自动读取/写入内存。

   #### C. 网络同步 (Replication)

   UE 的同步机制通过反射知道哪些变量标记了 `Replicated`，从而在后台自动比对变量值是否发生变化，并进行封包发送。

   #### D. 垃圾回收 (Garbage Collection)

   GC 系统通过反射找到所有 `UPROPERTY` 标记的指针，构建**引用通路图**。如果一个对象在图上不可达，就会被自动销毁。这也是为什么 UE 要求指向 UObject 的指针必须加上 `UPROPERTY()`，否则 GC 会以为没有引用而将其误杀。

   

### 组件有哪些类型？

| **类型**                | **父类**          | **有 Transform?** | **有物理/渲染?** | **主要职责**                 |
| ----------------------- | ----------------- | ----------------- | ---------------- | ---------------------------- |
| **Actor Component**     | `UObject`         | ❌ 否              | ❌ 否             | 纯逻辑、属性管理、数据计算   |
| **Scene Component**     | `UActorComponent` | ✅ 是              | ❌ 否             | 定义层级关系、空间定位       |
| **Primitive Component** | `USceneComponent` | ✅ 是              | ✅ 是             | 模型渲染、物理碰撞、特效展示 |

### FName、FTEXT、FString怎么实现的？

#### 1. FString：动态字符串（The "Workhorse"）

`FString` 是最接近普通字符串（如 `std::string`）的类型。它是三者中唯一**可修改**的。

- **实现原理：**
  - 底层是一个 `TArray<TCHAR>`。
  - `TCHAR` 在 Windows 下通常是 `wchar_t`（UTF-16），在其他平台可能是 `char16_t`。
  - 它支持各种操作：拼接、截取、查找、大小写转换等。
- **内存特性：** 数据存储在**堆（Heap）**上，具有动态扩容机制。
- **适用场景：** 临时的字符串处理、日志输出、解析文件。

#### 2. FName：硬编码名称（The "Id"）

`FName` 是为了性能极致优化的类型。它通过**字符串池化（String Pooling）技术，将字符串转化为极其高效的索引**。

- **实现原理：**
  - **全局哈希表（Name Table）：** 引擎维护一个全局唯一的字符串池。
  - **两级寻址：** 当你创建一个 `FName` 时，引擎会计算字符串的哈希，并去全局池中查找。
    - 如果已存在，返回现有的索引。
    - 如果不存在，将字符串存入池中并返回新索引。
  - **结构：** `FName` 本身只占 **8 字节**（由一个 `Index` 索引和一个 `Number` 实例编号组成）。
- **核心优势：**
  - **对比极快：** 两个 `FName` 比较时，只比两个整数是否相等，而不需要逐字符对比。
  - **内存极省：** 相同的名字在内存中只存一份。
- **缺点：** 无法直接修改字符串；由于池化，它是不可逆的（很难从池中删除）。
- **适用场景：** 资源路径、骨骼节点名、属性查找键（Key）、材质参数名。

#### 3. FText：本地化文本（The "User-Facing"）

`FText` 是专门为**多语言本地化（Localization）**设计的。

- **实现原理：**
  - **不仅仅是字符串：** 它不仅仅存储文本，还存储了一个**命名空间（Namespace）和一个键（Key）**。
  - **动态解析：** 在运行时，`FText` 会根据当前玩家设置的语言，去本地化表（.locres 文件）中查找真正的显示内容。
  - **引用计数：** 底层使用 `TSharedRef` 指向一个包含源字符串、显示字符串及文化信息的对象。
- **核心特性：**
  - **不可变性：** 一旦创建，其内容不能被像 `FString` 那样随机修改。
  - **格式化：** 支持强大的格式化功能（如 `FText::Format`）。
- **适用场景：** 所有展示给玩家看的内容（UI 文本、任务描述、对话）。

------

深度对比总结

| **特性**             | **FString**            | **FName**           | **FText**             |
| -------------------- | ---------------------- | ------------------- | --------------------- |
| **底层实现**         | `TArray<TCHAR>`        | 全局池索引 (Index)  | 键值对 + 本地化管理器 |
| **可变性**           | 可变 (Mutable)         | 不可变              | 不可变                |
| **大小（对象本身）** | 12-16 字节 (指针+长度) | 8-12 字节 (双整数)  | 较重的引用计数结构    |
| **搜索/比较速度**    | 慢 (逐字符对比)        | **极快** (整数对比) | 慢 (取决于解析后内容) |
| **本地化支持**       | ❌ 无                   | ❌ 无                | ✅ 完整支持            |
| **典型用途**         | 临时处理、逻辑运算     | 资源路径、骨骼名称  | UI 界面、对话、提示   |



### 转换关系图

在开发中，它们之间可以互相转换，但要注意开销：

- **FString → FName：** 较慢（涉及哈希计算和查表）。
- **FName → FString：** 较快（直接从池中取字符串）。
- **FString → FText：** 建议只用于调试，因为丢失了本地化键值。
- **FText → FString：** 不推荐（会失去本地化关联）。

C++

```
// 示例
FString MyStr = TEXT("HelloUE");
FName MyName = FName(*MyStr);         // FString 转 FName
FText MyText = FText::FromString(MyStr); // FString 转 FText
```

**一句话口诀：**

- 处理逻辑用 `FString`
- 寻找资源用 `FName`
- 展示界面用 `FText`

您是否想深入了解 `FName` 在全局池中是如何通过 `EntryId` 找到具体内存位置的，或者是想了解 `FText` 的格式化占位符原理？



## 图形学

### 图形渲染管线？

渲染管线（Graphics Pipeline）是将 **3D 场景中的几何信息（顶点、索引）** 转换为 **2D 屏幕图像** 的一系列处理流程。它主要分为四个阶段：**应用阶段、几何阶段、光栅化阶段、像素处理阶段。

#### I. 应用阶段 (Application Stage)

**发生在 CPU 中。**

- **任务：** 准备数据。包括剔除（Culling）【物体/网格级】、排序（Sorting）、将模型数据（顶点位置、UV、法线）压入显存，并设置渲染状态（Draw Call）。
- “Draw Call 优化”，如合批（Batching）是为了减少 CPU 与 GPU 的通信开销。

#### II. 几何阶段 (Geometry Stage)

**发生在 GPU 中，处理“点”和“线”。**

1. **顶点着色器 (Vertex Shader)：** 核心任务是 **坐标空间变换** (MVP变换)。同时计算逐顶点光照。
2. **曲面细分/几何着色器 (可选)：** 动态修改几何结构。
3. **投影/裁剪 (Clipping)：** 将不在视锥体内的几何体切除。【图元级】
4. **屏幕映射：** 将单位化的设备坐标转换为屏幕像素坐标。

#### III. 光栅化阶段 (Rasterization Stage)

**将“矢量几何”离散化为“像素阵列”。**

1. **三角形设置/遍历：** 寻找哪些像素被三角形覆盖。
2. **插值 (Interpolation)：** 将顶点的属性（如颜色、UV）线性插值给每个像素。

- **输出：** 产生**片元（Fragment）**。注意：片元还不是最终像素，它包含位置、深度、颜色等信息。

#### IV. 像素处理阶段 (Pixel Processing)

1. **片元着色器 (Fragment Shader)：** 计算光照、采样贴图（法线贴图、PBR 材质）。这是性能消耗最集中的地方。

2. **逐片元操作 (Merging)：**（顺序：裁剪 -> Alpha -> 模板 -> 深度）

   - **裁剪测试 (Scissor Test)：**视口和屏幕范围不一致时需要开启。
   - **Alpha测试**：根据物体的透明度来决定是否渲染。
   - **模板测试 (Stencil Test)：** 处理描影、遮罩。

   - **深度测试 (Depth Test)：** 决定物体遮挡关系。【支持Early-Z管线的硬件中，深度测试在光栅化之后，片元着色器之前】
   - **混合 (Blending)：** 处理半透明物体。

---



### 判断射线与AABB相交？

进入：x、y、z所有最小的最大值

离开：所有最大的最小值

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

struct Vec3 {
    float x, y, z;
};

struct Ray {
    Vec3 origin;
    Vec3 direction; // 建议预计算 invDirection = 1.0 / direction 以加速
    Vec3 invDirection; 
};

struct AABB {
    Vec3 min;
    Vec3 max;
};

bool isIntersect(const Ray& ray, const AABB& aabb, float& t_result) {
    float t1 = (aabb.min.x - ray.origin.x) * ray.invDirection.x;
    float t2 = (aabb.max.x - ray.origin.x) * ray.invDirection.x;
    
    // 确保 tmin 是进入点，tmax 是离开点
    float tmin = std::min(t1, t2);
    float tmax = std::max(t1, t2);

    // Y 轴
    float t3 = (aabb.min.y - ray.origin.y) * ray.invDirection.y;
    float t4 = (aabb.max.y - ray.origin.y) * ray.invDirection.y;
    
    tmin = std::max(tmin, std::min(t3, t4));
    tmax = std::min(tmax, std::max(t3, t4));

    // Z 轴
    float t5 = (aabb.min.z - ray.origin.z) * ray.invDirection.z;
    float t6 = (aabb.max.z - ray.origin.z) * ray.invDirection.z;

    tmin = std::max(tmin, std::min(t5, t6));
    tmax = std::min(tmax, std::max(t5, t6));

    // 相交条件：
    // 1. 各维度的交集区间不为空 (tmax >= tmin)
    // 2. AABB 不在射线起点的反方向 (tmax > 0)
    if (tmax >= tmin && tmax > 0) {
        t_result = tmin; // 如果 tmin < 0，说明起点在 AABB 内部
        return true;
    }

    return false;
}
```



### PBR



## Lua

### 优化技巧？

#### 使用local

Lua 5.0之后,Lua采用了一种类似于**寄存器**的虚拟机模式 Lua用栈来储存其寄存器 每一个活动的函数,Lua都会其分配一个栈,这个栈用来储存函数里的活动记录 每一个函数的栈都可以储存至多250个寄存器,因为栈的长度是用8个比特表示的 有了这些寄存器,Lua的预编译器能把所有的local变量储存在其中使得Lua在获取local变量时其效率很高【避免栈式虚拟机计算时频繁push/pop】

#### 表table

Lua 中的每个表都有两个部分：**数组**部分和**哈希**部分（开放寻址）。数组部分存储键为 1 到 n（对于某个特定的 n）范围内的整数的条目。

当 Lua 需要向表中插入新键且哈希数组已满时，Lua 会进行重哈希（**rehash**）。重哈希的第一步是确定新数组部分和新哈希部分的大小。为此，Lua 会遍历所有条目，对它们进行计数和分类，然后选择 2 的最大幂作为数组部分的大小，使得数组部分超过一半的元素都被填充。哈希部分的大小则是能容纳所有剩余条目（即那些无法放入数组部分的条目）的最小 2 的幂。

当创建一个空表时,数组和哈希部分的长度都将初始化为0,即不会为它们初始化任何数组

```lua
local a = {}
for i=1,3 do
	a[i] = true
end
```

最开始,Lua创建了一个空表a,在第一次迭代中,a[1] = true触发了一次rehash,Lua将数组部分的长度设置为2^0,即1,哈希部分仍为空 在第二次迭代中,a[2] = true再次触发了rehash,将数组部分长度设为2^1,即2最后一次迭代,又触发了一次rehash,将数组部分长度设为2^2,即4



**优化方法**：

如果有很多非常多的很小的表需要创建时,可以将其预先填充以避免rehash 比如:{true,true,true},Lua知道这个表有三个元素,所以Lua直接创建了三个元素长度的数组 类似的,{x=1, y=2, z=3},Lua会在其哈希部分中创建长度为4的数组



#### 字符串

优点：

- 所有的字符串在Lua中都只储存一份拷贝 当新字符串出现时,Lua检查是否有其相同的拷贝,若没有则创建它,否则,指向这个拷贝 这可以使得字符串比较和表索引变得相当的快,因为**比较字符串只需要检查引用是否一致**即可；
- 同理，**复制**时也很高效，只需要复制引用。

缺点：

- 但是这也**降低了创建字符串时的效率**,因为Lua需要去查找比较一遍。

- 只保存引用会降低在**字符串连接**时的速度,需要获取整个字符串的拷贝,然后将新增内容添加到拷贝的末尾,而复制buffer的赋值处理在拼接字符串时,只需要将新增内容插入buffer的末尾即可。

优化方法：

```lua
-- 可以用table来模拟buffer,下面的代码只需花费0.72秒,9倍效率提升
a = os.clock()
local s = ''
local t = {}
for i = 1,300000 do
	t[#t + 1] = 'a'
end
s = table.concat( t, '')
b = os.clock()
print(b-a) --0.07178
```

在大字符串连接中,应避免 `..` 使用table来模拟buffer,然后`concat`得到最终字符串

#### 3R原则

##### 减量化(Reducing)

有许多办法能够避免创建新对象和节约内存 例如:如果程序中使用了太多的表,需要考虑换一种数据结构来表示【AoS ->  SoA】

```lua
-- 更节省内存的方法
polyline = {
	x = {1.1, 1.1, 4.6, ...},
	y = {2.9, 3.7, 5.2, ...}
}
```

##### 再利用(Reusing)

##### 再循环(Recycling)

Lua的垃圾回收器是一个增量运行的机制 即回收分成许多小步骤(增量的)来进行。

频繁的垃圾回收可能会降低程序的运行效率 可以通过Lua的 `collectgarbage `函数来控制垃圾回收器。

`collectgarbage` 函数提供了多项功能:停止垃圾回收,重启垃圾回收,强制执行一次回收循环,强制执行一步垃圾回收,获取Lua占用的内存,以及两个影响垃圾回收频率和步幅的参数。

对于批处理的Lua程序来说,停止垃圾回收 `collectgarbage("stop")` 会提高效率,因为批处理程序在结束时,内存将全部被释放。



### 热更新？

#### _ENV

**是一个 Upvalue**：每一个 Lua 函数（Chunk）在加载时，都会隐式地关联一个名为 `_ENV` 的 Upvalue。

**默认指向 `_G`**：在默认情况下，Lua 加载一个文件时，会将该文件的 `_ENV` 初始化为指向全局表 `_G`。这就是为什么你直接写 `a = 1` 就能在 `_G` 里找到它的原因。

#### package.loaded

Lua的 `require(modulename)` 把一个lua文件加载存放到 `package.loaded[modulename]`。 
当我们加载一个模块的时候，会先判断是否在package.loaded中已存在，若存在则返回改模块，不存在才会加载(loadfile)，防止重复加载。

> package.loaded是一个Table，其中包含了全局表_G、默认加载的模块(string, debug, package, io, os, table, math, coroutine)和用户加载的模块。

#### 热更新实现

- 更新**模块的外壳**

```lua
function reload_module(module_name)
    local old_module = _G[module_name]
    -- 清理缓存并重新加载
    package.loaded[module_name] = nil
    require (module_name)
    -- 新旧交替：外部持有 old_module 引用的地方，因为 Table 的地址没变，所以它们看到的函数和数据立刻变成了新版本。
    local new_module = _G[module_name]
    for k, v in pairs(new_module) do
		local old_func = old_module[k]
        local new_func = v
        
        -- 【关键步骤】：如果新旧对应位置都是函数，先进行Upvalue 迁移
        if type(old_func) == "function" and type(new_func) == "function" then
            -- 这里调用下面第二块代码
            hotfix.update(old_func, new_func)
        end
        
        -- 移植完数据后，再覆盖逻辑
        old_module[k] = v
    end
    -- 修正缓存记录，确保全系统只有这一个“容器”
    package.loaded[module_name] = old_module
end
```

- 更新函数的Upvalue（确保新函数执行时，用的是旧的变量）

```lua
-- hotfix.lua
local hotfix = {}

local function collect_uv(f, uv)
    local i = 1
    while true do
        local name, value = debug.getupvalue(f, i)
        if name == nil then -- 当所有上值收集完时，跳出循环
            break
        end
        
        if not uv[name] then
            uv[name] = { func = f, index = i } -- 这里就会收集到旧函数 print_index 所有的上值，包括变量 index
            if type(value) == "function" then
                collect_uv(value, uv)
            end
        end

        i = i + 1
    end
end

local function update_func(f, uv) 
    local i = 1
    while true do
        local name, value = debug.getupvalue(f, i)
        if name == nil then -- 当所有上值收集完时，跳出循环
            break
        end
        -- value 值为空，并且这个 name 在 旧的函数中存在
        if not value and uv[name] then 
            local desc = uv[name]
            -- 将新函数 f 的第 i 个上值引用旧模块 func 的第 index 个上值
            debug.upvaluejoin(f, i, desc.func, desc.index)
        end

         -- 只对 function 类型进行递归更新，对基本数据类型（number、boolean、string） 不管
        if type(value) == "function" then
            update_func(value, uv)
        end

        i = i + 1
    end
end

function hotfix.update(old, new)
    local uv = {}
    collect_uv(old, uv)
    update_func(new, uv)
end

return hotfix
```



### Lua和C++/C# 交互？

#### Lua 虚拟栈

1. 栈的作用

- 是 Lua 与 C++/C# 交互的唯一数据通道，所有类型数据（数字、字符串、表、函数等）的传递均通过栈完成
- C++/C# 向 Lua 传值：先将值压入栈，再由 Lua 从栈中读取
- Lua 向 C++/C# 传值：Lua 将值压入栈，再由 C++/C# 从栈中读取

2. 栈的索引规则

| 索引类型 | 规则                  | 示例（栈内有 3 个元素时）          |
| -------- | --------------------- | ---------------------------------- |
| 正向索引 | 从栈底开始，1 为栈底  | 1（栈底元素）、2、3（栈顶元素）    |
| 反向索引 | 从栈顶开始，-1 为栈顶 | -1（栈顶元素）、-2、-3（栈底元素） |

3. 栈的核心操作函数（通用）

| 函数功能                 | C++ API                    | C#（XLua）API                       |
| ------------------------ | -------------------------- | ----------------------------------- |
| 获取栈顶索引（栈长度）   | `lua_gettop(lua_State *L)` | `LuaAPI.lua_gettop(RealStatePtr L)` |
| 清空栈                   | `lua_settop(L, 0)`         | `LuaAPI.lua_settop(L, 0)`           |
| 压入值（示例：字符串）   | `lua_pushstring(L, "str")` | `LuaAPI.lua_pushstring(L, "str")`   |
| 取值（示例：字符串）     | `lua_tostring(L, idx)`     | `LuaAPI.lua_tostring(L, idx)`       |
| 判断值类型（示例：数字） | `lua_isnumber(L, idx)`     | `LuaAPI.lua_isnumber(L, idx)`       |

#### Lua 与 C++ 交互

##### Lua函数（传给C++）

当你调用 `lua_getglobal(L, "add")` 时，Lua 会在全局表 `_G` 中查找键名为 "add" 的值。

在 Lua 内部，栈帧（Stack Slot）是一个名为 `TValue` 的结构体。对于函数，这个 `TValue` 的内容大致如下：

- **类型标记 (Type Tag)**：标记为 `LUA_TFUNCTION`。
- **值 (Value)**：一个指针，指向内存中的 **LClosure (Lua 闭包)** 结构体。

**LClosure 结构体里有什么？**

这个被压入栈的“函数对象”包含三个核心部分：

- **Proto 指针**：指向该函数对应的**字节码**。这才是真正的“代码逻辑”。
- **Upvalues 数组**：保存了该函数捕获的外部局部变量引用（这也就是为什么 Lua 函数叫“闭包”的原因）。
- **Env 指针**：指向该函数执行时的环境（通常是 `_ENV`）。

##### C 闭包（传给Lua）

`CClosure` 结构体：

- **函数指针 (f)**：指向你定义的符合 `int (*lua_CFunction) (lua_State *L)` 原型的函数。
- **Upvalues**：C 函数也可以拥有自己的“闭包变量”，这些变量存储在 `CClosure` 内部。

##### C++ 调用 Lua

（1）核心流程

1. 创建 Lua 状态机：`lua_State *L = luaL_newstate();`
2. 加载 Lua 文件：`luaL_loadfile(L, "xxx.lua")`
3. 运行 Lua 文件：`lua_pcall(L, 0, 0, 0)`（参数：状态机、入参个数、返回值个数、错误处理函数索引）
4. 操作 Lua 数据（变量、表、函数）
5. 关闭状态机：`lua_close(L);`

（2）操作示例

① 获取 Lua 全局变量

```cpp
// Lua 脚本（hello.lua）：str = "I am x-man."
lua_getglobal(L, "str"); // 将 Lua 全局变量 str 的值压入栈顶
string str = lua_tostring(L, -1); // 从栈顶（-1）读取字符串
cout << "str = " << str << endl;
```

② 获取 Lua 表（table）

```cpp
// Lua 脚本（hello.lua）：tbl = {name = "DC", id = 20114442}
lua_getglobal(L, "tbl"); // 将 tbl 压入栈（索引 -1）
lua_getfield(L, -1, "name"); // 取 tbl.name，压入栈顶（索引 -1）
string name = lua_tostring(L, -1); // 读取 name
lua_getfield(L, -2, "id"); // 取 tbl.id（tbl 在索引 -2），压入栈顶
int id = lua_tonumber(L, -1); // 读取 id
cout << "tbl:name = " << name << ", tbl:id = " << id << endl;
```

③ 调用 Lua 函数

```cpp
// Lua 脚本（hello.lua）：function add(a,b) return a + b end
lua_getglobal(L, "add"); // 压入函数 add（索引 -1）
lua_pushnumber(L, 10); // 压入第一个参数（索引 -2）
lua_pushnumber(L, 20); // 压入第二个参数（索引 -3）
int ret = lua_pcall(L, 2, 1, 0); // 调用函数（2个参数，1个返回值）
if (ret == 0 && lua_isnumber(L, -1)) {
    int result = lua_tonumber(L, -1); // 读取返回值（30）
    cout << "Result is " << result << endl;
}
```

##### Lua 调用 C++

（1）核心流程

1. 将 C++ 函数包装为 `lua_CFunction` 类型（接收 `lua_State*`，返回值个数）
2. 注册包装函数到 Lua 环境
3. Lua 中直接调用注册的函数

（2）操作示例

① 包装并注册普通函数

```cpp
// 1. 原始 C++ 函数
int add(int a, int b) { return a + b; }

// 2. 包装为 lua_CFunction
int lua_add(lua_State *L) {
    int a = lua_tonumber(L, 1); // 从栈索引 1 取第一个参数
    int b = lua_tonumber(L, 2); // 从栈索引 2 取第二个参数
    int sum = a + b;
    lua_pushnumber(L, sum); // 压入返回值
    return 1; // 返回值个数为 1
}

// 3. 注册到 Lua
lua_register(L, "lua_add", lua_add); // Lua 中可调用 lua_add(a,b)

// 4. Lua 脚本（avg.lua）：print(lua_add(10,20)) → 输出 30
```

② 封装为 Lua 模块

```cpp
// 1. 定义模块函数列表
static const luaL_Reg mylib_funcs[] = {
    {"add", lua_add}, // 函数名（Lua 中）：add；对应包装函数：lua_add
    {NULL, NULL} // 结束标记
};

// 2. 模块加载函数
int lua_openmylib(lua_State *L) {
    luaL_newlib(L, mylib_funcs); // 创建表存储模块函数，压入栈
    return 1; // 返回模块表
}

// 3. 注册模块到 Lua
const luaL_Reg lua_reg_libs[] = {
    {"base", luaopen_base}, // Lua 基础库
    {"mylib", lua_openmylib}, // 自定义模块（名：mylib）
    {NULL, NULL}
};

// 4. Lua 脚本调用：local sum = mylib.add(10,20) → 30
```

#### Lua 与 C#（XLua）交互

核心原理

- 基于 C API 封装，通过 **P/Invoke** （托管代码中访问非托管库中的结构、回调和函数） 调用 Lua 虚拟机函数（核心封装类：`LuaDLL.cs`、`LuaAPI.cs`）
- C# 对象在 Lua 中以 `userdata` 形式存在，通过「**索引**」保持引用，元表（metatable）存储类型信息（方法、属性）
- 数据交互依赖 `ObjectTranslator`：管理 C# 与 Lua 对象的映射、类型注册、垃圾回收同步

##### C#（XLua）调用 Lua

（1）核心方式：类型映射

- 引用类型映射：实现 `LuaBase` 接口（如 `LuaTable`、`LuaFunction`），标记 `[CSharpCallLua]` 特性，双向同步修改
- 值类型映射：直接取值，无后续关联（如 `int`、`string`）

（2）操作示例

① 获取 Lua 全局变量 / 表

```csharp
// 创建 Lua 环境
LuaEnv luaEnv = new LuaEnv();
// 加载并运行 Lua 脚本
luaEnv.DoString(@"
    str = 'I am x-man.'
    tbl = {name = 'DC', id = 20114442}
");

// 获取全局变量 str（值类型）
string str = luaEnv.Global.Get<string>("str");
Console.WriteLine("str = " + str);

// 获取表 tbl（引用类型）
LuaTable tbl = luaEnv.Global.Get<LuaTable>("tbl");
string name = tbl.Get<string>("name");
int id = tbl.Get<int>("id");
Console.WriteLine("tbl:name = " + name + ", tbl:id = " + id);

// 释放环境
luaEnv.Dispose();
```

② 调用 Lua 函数

```csharp
// Lua 脚本：function add(a,b) return a + b end
LuaEnv luaEnv = new LuaEnv();
luaEnv.DoString("function add(a,b) return a + b end");

// 方式1：通过 LuaFunction 调用
LuaFunction addFunc = luaEnv.Global.Get<LuaFunction>("add");
object[] result = addFunc.Call(10, 20);
Console.WriteLine("Result = " + result[0]); // 输出 30

// 方式2：映射为委托（推荐，类型安全）
[CSharpCallLua]
public delegate int AddDelegate(int a, int b);

AddDelegate add = luaEnv.Global.Get<AddDelegate>("add");
int sum = add(10, 20);
Console.WriteLine("Sum = " + sum); // 输出 30

luaEnv.Dispose();
```

##### Lua 调用 C#

（1）核心流程

1. 注册 C# 类型 / 函数到 Lua：通过生成 `wrap` 代码（静态方法，封装 C# 逻辑）或反射
2. Lua 中通过 `CS.命名空间.类型` 调用（如 `CS.UnityEngine.GameObject`）

（2）操作示例

① 注册 C# 类与方法

```csharp
// 1. 定义 C# 类
public class Test {
    public string Name { get; set; }
    public int Add(int a, int b) { return a + b; }
    public static void Log(string msg) { Console.WriteLine(msg); }
}

// 2. 生成 wrap 代码（需配置 XLua 生成规则），或通过反射注册
// 3. Lua 脚本调用
luaEnv.DoString(@"
    -- 创建实例
    local test = CS.Test()
    test.Name = 'DC'
    print(test.Name) -- 输出 DC
    
    -- 调用实例方法
    local sum = test.Add(10,20)
    print(sum) -- 输出 30
    
    -- 调用静态方法
    CS.Test.Log('Hello XLua') -- 输出 Hello XLua
");
```

② 注册 C# 委托（Lua 调用 C# 委托）

```csharp
// 1. 定义委托并标记特性
[CSharpCallLua]
public delegate void LogDelegate(string msg);

// 2. C# 中定义委托方法
public static void CSharpLog(string msg) {
    Console.WriteLine("CSharpLog: " + msg);
}

// 3. 注册到 Lua
LuaEnv luaEnv = new LuaEnv();
luaEnv.Global.Set("CSharpLog", new LogDelegate(CSharpLog));

// 4. Lua 脚本调用
luaEnv.DoString("CSharpLog('From Lua')"); // 输出 CSharpLog: From Lua
```



关键差异对比

| 维度     | Lua 与 C++                        | Lua 与 C#（XLua）                                            |
| -------- | --------------------------------- | ------------------------------------------------------------ |
| 调用底层 | 直接调用 Lua C API                | 基于 P/Invoke 封装 C API                                     |
| 对象映射 | 无自动映射，需手动处理指针 / 索引 | `ObjectTranslator` 自动管理对象索引与元表                    |
| 代码生成 | 无需额外生成代码                  | 需生成代码（或依赖反射），支持特性标记（如 `[CSharpCallLua]`） |
| 垃圾回收 | 需手动同步栈与对象生命周期        | 自动同步（基于 `__gc` 元方法与 `Dispose`）                   |
| 易用性   | 灵活性高，需手动处理栈操作        |                                                              |



## 数据结构与算法

###  再哈希法 / 双哈希法 (Double Hashing)中出现无限循环怎么办

保证步长和表长互质，确保探测序列能覆盖哈希表中的每一个槽位。





### 哈希表扩容的卡顿优化？

#### 增量扩容 / 渐进式 rehash

> 不一次性搬迁所有元素，而是 **把 rehash 拆成多次小步骤，分摊到后续的插入 / 查找操作中**。

典型做法（以 Redis / Lua table 为例）：

- 同时维护 **old table + new table**
- 维护一个 全局`rehash_idx`（记录当前搬到哪里了）
- 每次 insert / find 时：
  - 顺带搬迁 1~k 个 bucket
- 查询时：
  - 先查 new table
  - 再查 old table

#### 分段/桶哈希

不把整个哈希表当成一个整体，而是拆成多个相互独立的小哈希表（段 / 桶），分别管理、分别扩容。

```
HashTable
 ├── Segment 0 → HashTable0
 ├── Segment 1 → HashTable1
 ├── Segment 2 → HashTable2
 └── Segment k-1 → HashTable(k-1)
```

key映射到segment：

```
h = hash(key);

segment_id = h % num_segments;
bucket_id  = (h / num_segments) % buckets_per_segment;
```

或

```
segment_id = high_bits(hash);
bucket_id  = low_bits(hash);
```





### 跳表

>  假如我要实现一个数据结构满足如下需求：我有若干个玩家，id不同且唯一，分别有个分数score，然后要实现：
>
> 插入（id，score） 更新（id，score） 删除（id，score） 获得id对应的分数rank，同一score可重复

哈希表 + 跳表（跳表本身所有操作logn）

<img src="D:\Projects\NOTES\images\image-20260111164141271.png" alt="image-20260111164141271" style="zoom: 67%;" />

跳表节点：

```cpp
struct SkipListNode {
    string obj;           // 玩家ID (Member)
    double score;         // 分数 (Score)
    SkipListNode* backward; // 后退指针（可选）	

    struct Level {
        SkipListNode* forward; // 前进指针
        unsigned int span;     // 跨度：当前节点到下个节点跳过了多少个节点
    } levels[]; // 动态长度的层级数组
};
```



### 树状数组/线段树

#### 树状数组

主要支持logn的单点更新和前缀和查询

#### 线段树

建树n，更新/查询（区间和、区间最大/小值）logn



### 定时器

**最小堆**实现



### 圆内随机撒点

#### 极坐标转换法

如果我们直接在 $[0, R]$ 范围内随机取半径 $r$，由于圆外圈的面积比内圈大，点会堆积在中心。

为了实现均匀分布，**半径的随机值必须经过开方处理**。

#### 算法逻辑：

1. 生成两个独立且分布均匀的随机数：

   - $$
     u \in [0, 1]
     $$

     

   - $$
     v \in [0, 1]
     $$

     

2. 计算角度：
   $$
   \theta = 2\pi \cdot u
   $$
   
3. 计算半径：
   $$
   r = R \cdot \sqrt{v}
   $$

4. 转换为笛卡尔坐标：

   - $$
     x = x_0 + r \cdot \cos(\theta)
     $$

     

   - $$
     y = y_0 + r \cdot \sin(\theta)
     $$

     





## 计算机基础

### 链接

#### 具体过程？

A. 符号查找（Symbol Resolution）

链接器会扫描所有的 `.obj` 文件和库文件（`.lib`），构建一张**全局符号表**。

- **左边：** 谁在引用这个符号？（比如 `main.obj` 里的 `Attack` 调用）
- **右边：** 谁定义了这个符号？（比如 `Player.obj` 里的 `Attack` 实现）
- **连线：** 链接器把它们匹配起来。如果找不到定义，就会报经典的 **`LNK2019: 无法解析的外部符号`**。

B. 重定位（Relocation / 地址修正）

1. **确定基址：** 链接器将所有目标文件的代码段（`.text`）和数据段（`.data`）拼接在一起，确定每个函数在最终可执行文件中的**相对偏移量**。
2. **填空：** 链接器回到之前那些“占位符”的地方，把当初编译器留下的假地址（通常是 0 或 偏移量），改写成**真正的内存跳转地址**。

#### 静态链接、动态链接？

**静态链接**：编译器和汇编器将多个文件（模块）生成多个**可重定位的目标文件**，**静态链接器**在链接时将多个可重定位目标文件链接成可执行的文件（exe，.out 文件 ELF 格式）![img](D:\Projects\NOTES\images\v2-cfa13f874f3e9a2a43212ed57017277a_1440w.jpg)

**动态链接**：动态链接器需要在链接时先通过静态链接器传入一些重定位和符号信息，后续在可执行文件加载或者运行的时候先加载动态链接器（.interp 节中和包含动态链接器的路径，他本身就是一个共享库），随后根据重定位等信息将目标动态库文件加载到内存中。

![img](D:\Projects\NOTES\images\v2-e0a3804729d32b7b81f156cab6fc36b6_1440w.jpg)

#### 静态库、动态库？

**静态库**：任意个. o 文件的集合，程序 link 时，被复制到 output 文件。这个静态库文件是静态编译出来的，索引和实现都在其中，可以直接加到内存里面执行。

对于 Windows 上的静态库 .lib 有两种，一种和上面描述的一样，是任意个. o 文件的集合。程序 link 时，随程序直接加载到内存里面。另一种是辅助动态链接的实现（**导入库**），包含函数的描述和在 DLL 中的位置。也就是说，它为存放函数实现的 dll 提供索引功能，为了找到 dll 中的函数实现的入口点，程序 link 时，根据函数的位置生成函数调用的 jump 指令。（Linux 下动态链接器不需要导入库）

**动态库**：包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。（Linux 下. so 为后缀）



#### 内部链接、外部链接？

| **特性**       | **外部链接 (External)**                   | **内部链接 (Internal)**         |
| -------------- | ----------------------------------------- | ------------------------------- |
| **关键字**     | `extern` (默认)                           | `static` (全局), `const`        |
| **可见范围**   | 整个程序（跨 `.cpp`）                     | 仅限当前编译单元（当前 `.cpp`） |
| **符号表状态** | 导出为全局符号                            | 标记为私有/局部符号             |
| **典型用途**   | 全局共享配置、库函数                      | 隐藏辅助函数、常量定义          |
| **冲突风险**   | 高（容易发生 "multiple definition" 错误） | 低（文件名相同也不会报错）      |



### 协程？

在操作系统层面，协程被称为**“用户态线程”**（User-level Thread）或**“纤程”**（Fiber）。

#### **核心定义**

- **非抢占式（Non-preemptive）**：线程由操作系统内核调度，可以随时被强制中断（抢占）；协程由程序员在代码中手动控制，必须主动挂起（Yield）才能交出 CPU 控制权。
- **协作式（Cooperative）**：多个协程运行在同一个线程之上，彼此协作，不存在资源竞争的锁机制（因为同一时刻只有一个协程在跑）。

#### **运行机制**

协程拥有自己的**寄存器上下文**和**栈**。

1. **挂起（Yield）**：保存当前 CPU 寄存器的状态到协程的栈中，跳转回调度器的位置。
2. **恢复（Resume）**：从栈中恢复寄存器状态，跳回上次中断的代码地址继续执行。

------

#### Unity 协程的“伪”实现

Unity 中的协程与操作系统层面的原生协程**完全不同**。Unity 的协程本质上是基于 C# 的 **迭代器（Enumerator）** 实现的语法糖。

**核心机制：迭代器**

Unity 协程利用了 C# 的 `yield return` 特性。

- 当你编写 `yield return new WaitForSeconds(1.0f);` 时，函数并没有真正的“挂起”，而是返回了一个对象。
- Unity 的底层引擎（主线程）每一帧都会检查这些返回的对象，判断条件是否满足（时间是否到了？操作是否完成了？）。
- 如果满足，Unity 就调用迭代器的 `MoveNext()`，执行下一段代码。

------

对比：操作系统 vs. Unity

| **特性**     | **操作系统原生协程**           | **Unity 协程 (C# Enumerator)**  |
| ------------ | ------------------------------ | ------------------------------- |
| **底层实现** | 栈/寄存器上下文切换 (Stackful) | 状态机/迭代器 (Stackless)       |
| **执行位置** | 可跨线程或在单一线程           | **严格在主线程**                |
| **并行性**   | 逻辑并发                       | 逻辑分步（Time-slicing）        |
| **性能开销** | 极小（几百字节内存）           | 较大（产生 GC Alloc，每帧轮询） |
| **主要用途** | 高并发网络服务器               | 延时逻辑、异步流程控制          |



### memory_order 六种内存顺序?

1. **松散语义 (Relaxed)**：`memory_order_relaxed`。仅保证原子性，不保证任何执行顺序或内存屏障，开销最低。

2. **获取-释放语义 (Acquire-Release)**：

- `memory_order_acquire`：后续的读写操作不能重排到该操作之前（用于 `load`）。
- `memory_order_release`：之前的读写操作不能重排到该操作之后（用于 `store`）。
- `memory_order_acq_rel`：同时具备以上两者特性（用于 `read-modify-write`）。
- `memory_order_consume`：较弱的 acquire，仅保证有数据依赖的操作顺序（现代开发中不建议使用）。

3. **强顺序语义 (Sequential Consistency)**：`memory_order_seq_cst`。这是**默认顺序**，它保证所有线程看到的操作顺序完全一致，会禁止几乎所有可能的重排，性能开销最大。



### 缓存一致性如何实现？

#### 硬件层

MESI协议 用**缓存行状态**来协调多核访问

| 状态          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| M (Modified)  | 该数据已修改，需要在合适的时机写回内存；                     |
| E (Exclusive) | 该数据独占，意指此时该数据只存在某个核中，其他核没有该数据，于是就不需要所谓的广播给其他的核，也就没有缓存一致性的问题 |
| S (Shared)    | 数据共享，是从**E**状态转移过来的。意指多个核中都有该数据，这个时候就会存在缓存一致性的问题 |
| I (Invalid)   | 表示数据已失效，可以丢弃掉Cache Block的数据了（高并发情况下可能出现两个CPU同时修改变量a，并同时向总线发出将各自的缓存行更改为M状态的情况，**此时总线会采用相应的裁决机制进行裁决**，将其中一个置为M状态，另一个置为I状态，且I状态的缓存行修改无效） |

<img src="D:\Projects\NOTES\images\v2-5bd2b5e4b4bc9239f75ab94128fefcb7_1440w.jpg" alt="img" style="zoom: 67%;" />



#### 软件层

1. `volatile` 关键字告诉编译器：“这个变量随时可能被外部（如另一个线程）修改，**不要把它优化到寄存器里**”

2. 编译器提供了一些内置函数（如 `std::atomic_thread_fence`）。它们会生成特殊的机器指令，强制 CPU 把积压在 Store Buffer 里的数据刷入缓存，从而让 MESI 协议能感知到数据变化。

3. 原子操作，如C++ `std::atomic`

4. 互斥锁、信号量

5. 数据布局优化（防止**伪共享**【MESI只是缓存行级别的一致性协议，会导致伪共享】）

   - **对齐与填充（Padding/Alignment）**： 在代码中手动加入填充字节，确保高频访问的并发变量位于不同的缓存行。

     ```cpp
     struct Counter {
         alignas(64) std::atomic<int> value1; // 强制对齐到 64 字节（缓存行大小）
         alignas(64) std::atomic<int> value2; 
     };
     ```



## 操作系统

### 并发

#### 死锁有哪些必要条件？

1. **互斥**：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）

   解决：CAS指令，无需锁，允许空转一小会

2. **持有并等待**：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例 如，需要获得的锁）。 

   解决：原子地抢锁（加一把大锁prevention）

3. **非抢占**：线程获得的资源（例如锁），不能被抢占。

   解决：`trylock `尝试获取锁，没抢到可以重试（随机时间后）

4. **循环等待**：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这 个资源又是下一个线程要申请的。

   解决：获取锁的顺序一致。
   
   

### 进程/线程通信？

1. 进程间通信 (IPC - Inter-Process Communication)

由于每个进程都有独立的虚拟地址空间（内存隔离），一个进程不能直接访问另一个进程的变量。因此，IPC 必须借助**内核（Kernel）**作为中转站。

主要方式：

- **管道 (Pipe)：** * **匿名管道：** 仅限父子进程。
  - **命名管道 (FIFO)：** 允许无亲缘关系进程通信。
- **消息队列 (Message Queue)：** 消息的链表，存放在内核中。相比管道，它支持有格式的数据，可以按类型读取。
- **共享内存 (Shared Memory)：** * **最快**的 IPC 方式。
  - 操作系统映射一段物理内存到多个进程的地址空间。由于没有数据拷贝开销，效率极高，但需要配合“信号量”来同步。
- **信号量 (Semaphore)：** 实际上是一个计数器，主要用于进程间的同步和互斥，防止资源竞争。
- **套接字 (Socket)：** 可跨机器通信，是网络编程的基础。

------

2. 线程间通信

线程共享所属进程的资源（如代码段、数据段、堆），但拥有独立的栈。因此，线程通信的本质是**在共享空间内进行同步**。

主要方式：

- **共享变量 (Shared Variables)：** 线程可以直接读写全局变量或堆上的对象。这是最直接的通信方式，但也最危险（易引发竞态条件）。
- **互斥锁 (Mutex) & 读写锁：** 保证同一时间只有一个线程访问共享资源。
- **条件变量 (Condition Variable)：** 用于线程间的“通知”。例如：生产者线程放好数据后，通知消费者线程可以取了。
- **信号量 (Semaphore)：** 同样适用于线程间，常用于控制并发访问某个资源的线程数量。
- **Future/Promise：** C++11 引入的异步结果获取机制，用于线程间一次性的结果传递。

------

3. 进程 vs 线程通信：深度对比

| **维度**     | **进程间通信 (IPC)**                         | **线程间通信**                                 |
| ------------ | -------------------------------------------- | ---------------------------------------------- |
| **内存空间** | **隔离**。必须跨越地址空间。                 | **共享**。在同一地址空间内进行。               |
| **开销**     | **大**。需要频繁进行内核态/用户态切换。      | **小**。直接访问内存，上下文切换极快。         |
| **复杂性**   | **高**。需要调用 OS 提供的 IPC 接口。        | **低**。可以直接修改变量，但同步逻辑难。       |
| **安全性**   | **好**。一个进程崩溃不会直接导致另一个崩溃。 | **差**。一个线程写错内存可能导致整个进程崩溃。 |
| **核心挑战** | 如何把数据高效地从 A 传到 B。                | 如何保护共享资源不被乱序改写（同步）。         |






## 计算机网络

[一文搞定 UDP 和 TCP 高频面试题！ - 知乎](https://zhuanlan.zhihu.com/p/108822858)





## 其他

### UE和Unity区别？

1. 编程语言与开发范式

2.  底层架构：组件化 vs 层次化

   - **Unity (ECS/OOP):** 传统的 **GameObject + Component** 模式，非常解耦。目前正在推行 **Data-Oriented Technology Stack (DOTS)**，追求极致的缓存命中率和多线程性能。
   - **UE (Inheritance-based):** 更多地依赖于**继承**（Actor -> Pawn -> Character）。它内置了非常重型的功能类，比如 `CharacterMovementComponent` 几乎处理了所有动作游戏需要的同步、碰撞和重力逻辑。

3. 物理和动画系统

4. 渲染管线与图形特性

   **Unity:** 提供 **URP (Universal Render Pipeline)** 和 **HDRP (High Definition Render Pipeline)**。

   - **特点：** 灵活性极高，开发者可以深入定制 SRP（Scriptable Render Pipeline），适合做二次元风格化（如《原神》）。

   **UE:** 以“开箱即用的写实感”著称。

   - **黑科技：** **Lumen**（全动态全局光照）和 **Nanite**（虚拟微多边形几何体）。
   - **深度回答：** “UE5 的 Nanite 改变了美术资产的管线，让高模直接进引擎成为可能；而 Unity 则给了开发者更多‘手动调优’和‘定制化渲染逻辑’的空间。”



### 点到直线的距离公式？

点到直线的距离公式是解析几何中非常基础且重要的公式。

1. 二维平面下的公式

设点 P 的坐标为 (x_0, y_0)，直线的方程为一般式：


$$
Ax + By + C = 0
$$


则点 P 到直线的距离 


$$
d = \frac{|Ax_0 + By_0 + C|}{\sqrt{A^2 + B^2}}
$$


2. 三维空间中的情况（点到直线的距离）

在三维空间中，直线通常由一个点 Q 和方向向量 
$$
\vec{v}
$$
表示。设空间一点为 P，则点 P 到直线的距离公式为：


$$
d = \frac{|\vec{QP} \times \vec{v}|}{|\vec{v}|}
$$



### 寻路

#### JPS算法

[JPS/JPS+ 寻路算法 - KillerAery - 博客园](https://www.cnblogs.com/KillerAery/p/12242445.html)

<img src="D:\Projects\NOTES\images\1409576-20200616170302471-1445524327.png" alt="img" style="zoom: 50%;" />
