## C++

### Rule of Five？

如果你编写的类需要手动管理资源（如原始指针、文件句柄、网络连接等），你通常需要同时显式定义 **5 个** 特殊成员函数。

```cpp
class ResourceManager {
    int* data;
    size_t size;

public:
    // 1. 析构函数 (Destructor) - 释放资源
    ~ResourceManager() {
        delete[] data;
    }

    // 2. 拷贝构造函数 (Copy Constructor) - 深拷贝
    ResourceManager(const ResourceManager& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // 3. 拷贝赋值运算符 (Copy Assignment) - 释放旧资源，拷贝新资源
    ResourceManager& operator=(const ResourceManager& other) {
        if (this != &other) {
            delete[] data; // 释放旧的
            size = other.size;
            data = new int[size];
            std::copy(other.data, other.data + size, data);
        }
        return *this;
    }

    // 4. 移动构造函数 (Move Constructor) - 窃取资源，原对象置空
    ResourceManager(ResourceManager&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr; // 关键：防止原对象析构时释放这块内存
        other.size = 0;
    }

    // 5. 移动赋值运算符 (Move Assignment) - 释放旧资源，窃取新资源
    ResourceManager& operator=(ResourceManager&& other) noexcept {
        if (this != &other) {
            delete[] data;      // 释放自己的
            data = other.data;  // 拿走别人的
            size = other.size;
            other.data = nullptr; // 别人置空
            other.size = 0;
        }
        return *this;
    }
};
```

### 编译器处理虚函数表？

 对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤： 

-  拷贝基类的虚函数表。如果是多继承，就**拷贝**每个有虚函数的基类的虚函数表（其中**主基类**的虚函数表被放在派生类对象内存布局的起始位置 ，派生类对象的第一个 vptr 指向的就是这张表）
- 查看派生类中是否有重写基类中的虚函数， 如果有，就**替换**成已经重写的虚函数地址；
- 查看派生类是否有自身的虚函数，如果有，就**追加**自身的虚函数到自身的虚函数表中。<img src="D:\Projects\NOTES\images\image-20260102224712731.png" alt="image-20260102224712731" style="zoom: 50%;" />

### dynamic_cast是怎么实现的？

dynamic_cast 属于 RTTI, 运行时类型识别的一个内容。主要内容是 **typeid** 与 **typeinfo** 的实现, 基本思路就是在有虚函数的类的虚表的头部位置存放 RTTI 的相关信息。在 VC 里面可以看到是一个叫做 RTTI Complete Object Locator 的结构体里面存放相关的信息。在强转的时候，会读取里面对应的类的信息进而判断是否能转换成功。

![img](D:\Projects\NOTES\images\v2-29ff744ae7eaf85424dd7f167fc15abf_r.jpg)



## 图形学

### 图形渲染管线？

渲染管线（Graphics Pipeline）是将 **3D 场景中的几何信息（顶点、索引）** 转换为 **2D 屏幕图像** 的一系列处理流程。它主要分为四个阶段：**应用阶段、几何阶段、光栅化阶段、像素处理阶段。

#### I. 应用阶段 (Application Stage)

**发生在 CPU 中。**

- **任务：** 准备数据。包括剔除（Culling）【物体/网格级】、排序（Sorting）、将模型数据（顶点位置、UV、法线）压入显存，并设置渲染状态（Draw Call）。
- “Draw Call 优化”，如合批（Batching）是为了减少 CPU 与 GPU 的通信开销。

#### II. 几何阶段 (Geometry Stage)

**发生在 GPU 中，处理“点”和“线”。**

1. **顶点着色器 (Vertex Shader)：** 核心任务是 **坐标空间变换** (MVP变换)。同时计算逐顶点光照。
2. **曲面细分/几何着色器 (可选)：** 动态修改几何结构。
3. **投影/裁剪 (Clipping)：** 将不在视锥体内的几何体切除。【图元级】
4. **屏幕映射：** 将单位化的设备坐标转换为屏幕像素坐标。

#### III. 光栅化阶段 (Rasterization Stage)

**将“矢量几何”离散化为“像素阵列”。**

1. **三角形设置/遍历：** 寻找哪些像素被三角形覆盖。
2. **插值 (Interpolation)：** 将顶点的属性（如颜色、UV）线性插值给每个像素。

- **输出：** 产生**片元（Fragment）**。注意：片元还不是最终像素，它包含位置、深度、颜色等信息。

#### IV. 像素处理阶段 (Pixel Processing)

1. **片元着色器 (Fragment Shader)：** 计算光照、采样贴图（法线贴图、PBR 材质）。这是性能消耗最集中的地方。

2. **逐片元操作 (Merging)：**（顺序：裁剪 -> Alpha -> 模板 -> 深度）

   - **裁剪测试 (Scissor Test)：**视口和屏幕范围不一致时需要开启。
   - **Alpha测试**：根据物体的透明度来决定是否渲染。
   - **模板测试 (Stencil Test)：** 处理描影、遮罩。

   - **深度测试 (Depth Test)：** 决定物体遮挡关系。【支持Early-Z管线的硬件中，深度测试在光栅化之后，片元着色器之前】
   - **混合 (Blending)：** 处理半透明物体。

---

### PBR



## Lua

### 优化技巧

#### 使用local

Lua 5.0之后,Lua采用了一种类似于**寄存器**的虚拟机模式 Lua用栈来储存其寄存器 每一个活动的函数,Lua都会其分配一个栈,这个栈用来储存函数里的活动记录 每一个函数的栈都可以储存至多250个寄存器,因为栈的长度是用8个比特表示的 有了这些寄存器,Lua的预编译器能把所有的local变量储存在其中使得Lua在获取local变量时其效率很高【避免栈式虚拟机计算时频繁push/pop】

#### 表table

Lua 中的每个表都有两个部分：**数组**部分和**哈希**部分（开放寻址）。数组部分存储键为 1 到 n（对于某个特定的 n）范围内的整数的条目。

当 Lua 需要向表中插入新键且哈希数组已满时，Lua 会进行重哈希（**rehash**）。重哈希的第一步是确定新数组部分和新哈希部分的大小。为此，Lua 会遍历所有条目，对它们进行计数和分类，然后选择 2 的最大幂作为数组部分的大小，使得数组部分超过一半的元素都被填充。哈希部分的大小则是能容纳所有剩余条目（即那些无法放入数组部分的条目）的最小 2 的幂。

当创建一个空表时,数组和哈希部分的长度都将初始化为0,即不会为它们初始化任何数组

```lua
local a = {}
for i=1,3 do
	a[i] = true
end
```

最开始,Lua创建了一个空表a,在第一次迭代中,a[1] = true触发了一次rehash,Lua将数组部分的长度设置为2^0,即1,哈希部分仍为空 在第二次迭代中,a[2] = true再次触发了rehash,将数组部分长度设为2^1,即2最后一次迭代,又触发了一次rehash,将数组部分长度设为2^2,即4



**优化方法**：

如果有很多非常多的很小的表需要创建时,可以将其预先填充以避免rehash 比如:{true,true,true},Lua知道这个表有三个元素,所以Lua直接创建了三个元素长度的数组 类似的,{x=1, y=2, z=3},Lua会在其哈希部分中创建长度为4的数组



#### 字符串

优点：

- 所有的字符串在Lua中都只储存一份拷贝 当新字符串出现时,Lua检查是否有其相同的拷贝,若没有则创建它,否则,指向这个拷贝 这可以使得字符串比较和表索引变得相当的快,因为**比较字符串只需要检查引用是否一致**即可；
- 同理，**复制**时也很高效，只需要复制引用。

缺点：

- 但是这也**降低了创建字符串时的效率**,因为Lua需要去查找比较一遍。

- 只保存引用会降低在**字符串连接**时的速度,需要获取整个字符串的拷贝,然后将新增内容添加到拷贝的末尾,而复制buffer的赋值处理在拼接字符串时,只需要将新增内容插入buffer的末尾即可。

优化方法：

```lua
-- 可以用table来模拟buffer,下面的代码只需花费0.72秒,9倍效率提升
a = os.clock()
local s = ''
local t = {}
for i = 1,300000 do
	t[#t + 1] = 'a'
end
s = table.concat( t, '')
b = os.clock()
print(b-a) --0.07178
```

在大字符串连接中,应避免 `..` 使用table来模拟buffer,然后`concat`得到最终字符串

#### 3R原则

##### 减量化(Reducing)

有许多办法能够避免创建新对象和节约内存 例如:如果程序中使用了太多的表,需要考虑换一种数据结构来表示【AoS ->  SoA】

```lua
-- 更节省内存的方法
polyline = {
	x = {1.1, 1.1, 4.6, ...},
	y = {2.9, 3.7, 5.2, ...}
}
```

##### 再利用(Reusing)

##### 再循环(Recycling)

Lua的垃圾回收器是一个增量运行的机制 即回收分成许多小步骤(增量的)来进行。

频繁的垃圾回收可能会降低程序的运行效率 可以通过Lua的 `collectgarbage `函数来控制垃圾回收器。

`collectgarbage` 函数提供了多项功能:停止垃圾回收,重启垃圾回收,强制执行一次回收循环,强制执行一步垃圾回收,获取Lua占用的内存,以及两个影响垃圾回收频率和步幅的参数。

对于批处理的Lua程序来说,停止垃圾回收 `collectgarbage("stop")` 会提高效率,因为批处理程序在结束时,内存将全部被释放。



### 热更新

#### _ENV

**是一个 Upvalue**：每一个 Lua 函数（Chunk）在加载时，都会隐式地关联一个名为 `_ENV` 的 Upvalue。

**默认指向 `_G`**：在默认情况下，Lua 加载一个文件时，会将该文件的 `_ENV` 初始化为指向全局表 `_G`。这就是为什么你直接写 `a = 1` 就能在 `_G` 里找到它的原因。

#### package.loaded

Lua的 `require(modulename)` 把一个lua文件加载存放到 `package.loaded[modulename]`。 
当我们加载一个模块的时候，会先判断是否在package.loaded中已存在，若存在则返回改模块，不存在才会加载(loadfile)，防止重复加载。

> package.loaded是一个Table，其中包含了全局表_G、默认加载的模块(string, debug, package, io, os, table, math, coroutine)和用户加载的模块。

#### 热更新实现

- 更新**模块的外壳**

```lua
function reload_module(module_name)
    local old_module = _G[module_name]
    -- 清理缓存并重新加载
    package.loaded[module_name] = nil
    require (module_name)
    -- 新旧交替：外部持有 old_module 引用的地方，因为 Table 的地址没变，所以它们看到的函数和数据立刻变成了新版本。
    local new_module = _G[module_name]
    for k, v in pairs(new_module) do
        old_module[k] = v
    end
    -- 修正缓存记录，确保全系统只有这一个“容器”
    package.loaded[module_name] = old_module
end
```

- 更新函数的Upvalue（确保新函数执行时，用的是旧的变量）

```lua
-- hotfix.lua
local hotfix = {}

local function collect_uv(f, uv)
    local i = 1
    while true do
        local name, value = debug.getupvalue(f, i)
        if name == nil then -- 当所有上值收集完时，跳出循环
            break
        end
        
        if not uv[name] then
            uv[name] = { func = f, index = i } -- 这里就会收集到旧函数 print_index 所有的上值，包括变量 index
            if type(value) == "function" then
                collect_uv(value, uv)
            end
        end

        i = i + 1
    end
end

local function update_func(f, uv) 
    local i = 1
    while true do
        local name, value = debug.getupvalue(f, i)
        if name == nil then -- 当所有上值收集完时，跳出循环
            break
        end
        -- value 值为空，并且这个 name 在 旧的函数中存在
        if not value and uv[name] then 
            local desc = uv[name]
            -- 将新函数 f 的第 i 个上值引用旧模块 func 的第 index 个上值
            debug.upvaluejoin(f, i, desc.func, desc.index)
        end

         -- 只对 function 类型进行递归更新，对基本数据类型（number、boolean、string） 不管
        if type(value) == "function" then
            update_func(value, uv)
        end

        i = i + 1
    end
end

function hotfix.update(old, new)
    local uv = {}
    collect_uv(old, uv)
    update_func(new, uv)
end

return hotfix
```



### Lua和C++/C# 交互

#### Lua 虚拟栈

1. 栈的作用

- 是 Lua 与 C++/C# 交互的唯一数据通道，所有类型数据（数字、字符串、表、函数等）的传递均通过栈完成
- C++/C# 向 Lua 传值：先将值压入栈，再由 Lua 从栈中读取
- Lua 向 C++/C# 传值：Lua 将值压入栈，再由 C++/C# 从栈中读取

2. 栈的索引规则

| 索引类型 | 规则                  | 示例（栈内有 3 个元素时）          |
| -------- | --------------------- | ---------------------------------- |
| 正向索引 | 从栈底开始，1 为栈底  | 1（栈底元素）、2、3（栈顶元素）    |
| 反向索引 | 从栈顶开始，-1 为栈顶 | -1（栈顶元素）、-2、-3（栈底元素） |

3. 栈的核心操作函数（通用）

| 函数功能                 | C++ API                    | C#（XLua）API                       |
| ------------------------ | -------------------------- | ----------------------------------- |
| 获取栈顶索引（栈长度）   | `lua_gettop(lua_State *L)` | `LuaAPI.lua_gettop(RealStatePtr L)` |
| 清空栈                   | `lua_settop(L, 0)`         | `LuaAPI.lua_settop(L, 0)`           |
| 压入值（示例：字符串）   | `lua_pushstring(L, "str")` | `LuaAPI.lua_pushstring(L, "str")`   |
| 取值（示例：字符串）     | `lua_tostring(L, idx)`     | `LuaAPI.lua_tostring(L, idx)`       |
| 判断值类型（示例：数字） | `lua_isnumber(L, idx)`     | `LuaAPI.lua_isnumber(L, idx)`       |

#### Lua 与 C++ 交互

##### Lua函数（传给C++）

当你调用 `lua_getglobal(L, "add")` 时，Lua 会在全局表 `_G` 中查找键名为 "add" 的值。

在 Lua 内部，栈帧（Stack Slot）是一个名为 `TValue` 的结构体。对于函数，这个 `TValue` 的内容大致如下：

- **类型标记 (Type Tag)**：标记为 `LUA_TFUNCTION`。
- **值 (Value)**：一个指针，指向内存中的 **LClosure (Lua 闭包)** 结构体。

**LClosure 结构体里有什么？**

这个被压入栈的“函数对象”包含三个核心部分：

- **Proto 指针**：指向该函数对应的**字节码**。这才是真正的“代码逻辑”。
- **Upvalues 数组**：保存了该函数捕获的外部局部变量引用（这也就是为什么 Lua 函数叫“闭包”的原因）。
- **Env 指针**：指向该函数执行时的环境（通常是 `_ENV`）。

##### C 闭包（传给Lua）

`CClosure` 结构体：

- **函数指针 (f)**：指向你定义的符合 `int (*lua_CFunction) (lua_State *L)` 原型的函数。
- **Upvalues**：C 函数也可以拥有自己的“闭包变量”，这些变量存储在 `CClosure` 内部。

##### C++ 调用 Lua

（1）核心流程

1. 创建 Lua 状态机：`lua_State *L = luaL_newstate();`
2. 加载 Lua 文件：`luaL_loadfile(L, "xxx.lua")`
3. 运行 Lua 文件：`lua_pcall(L, 0, 0, 0)`（参数：状态机、入参个数、返回值个数、错误处理函数索引）
4. 操作 Lua 数据（变量、表、函数）
5. 关闭状态机：`lua_close(L);`

（2）操作示例

① 获取 Lua 全局变量

```cpp
// Lua 脚本（hello.lua）：str = "I am x-man."
lua_getglobal(L, "str"); // 将 Lua 全局变量 str 的值压入栈顶
string str = lua_tostring(L, -1); // 从栈顶（-1）读取字符串
cout << "str = " << str << endl;
```

② 获取 Lua 表（table）

```cpp
// Lua 脚本（hello.lua）：tbl = {name = "DC", id = 20114442}
lua_getglobal(L, "tbl"); // 将 tbl 压入栈（索引 -1）
lua_getfield(L, -1, "name"); // 取 tbl.name，压入栈顶（索引 -1）
string name = lua_tostring(L, -1); // 读取 name
lua_getfield(L, -2, "id"); // 取 tbl.id（tbl 在索引 -2），压入栈顶
int id = lua_tonumber(L, -1); // 读取 id
cout << "tbl:name = " << name << ", tbl:id = " << id << endl;
```

③ 调用 Lua 函数

```cpp
// Lua 脚本（hello.lua）：function add(a,b) return a + b end
lua_getglobal(L, "add"); // 压入函数 add（索引 -1）
lua_pushnumber(L, 10); // 压入第一个参数（索引 -2）
lua_pushnumber(L, 20); // 压入第二个参数（索引 -3）
int ret = lua_pcall(L, 2, 1, 0); // 调用函数（2个参数，1个返回值）
if (ret == 0 && lua_isnumber(L, -1)) {
    int result = lua_tonumber(L, -1); // 读取返回值（30）
    cout << "Result is " << result << endl;
}
```

##### Lua 调用 C++

（1）核心流程

1. 将 C++ 函数包装为 `lua_CFunction` 类型（接收 `lua_State*`，返回值个数）
2. 注册包装函数到 Lua 环境
3. Lua 中直接调用注册的函数

（2）操作示例

① 包装并注册普通函数

```cpp
// 1. 原始 C++ 函数
int add(int a, int b) { return a + b; }

// 2. 包装为 lua_CFunction
int lua_add(lua_State *L) {
    int a = lua_tonumber(L, 1); // 从栈索引 1 取第一个参数
    int b = lua_tonumber(L, 2); // 从栈索引 2 取第二个参数
    int sum = a + b;
    lua_pushnumber(L, sum); // 压入返回值
    return 1; // 返回值个数为 1
}

// 3. 注册到 Lua
lua_register(L, "lua_add", lua_add); // Lua 中可调用 lua_add(a,b)

// 4. Lua 脚本（avg.lua）：print(lua_add(10,20)) → 输出 30
```

② 封装为 Lua 模块

```cpp
// 1. 定义模块函数列表
static const luaL_Reg mylib_funcs[] = {
    {"add", lua_add}, // 函数名（Lua 中）：add；对应包装函数：lua_add
    {NULL, NULL} // 结束标记
};

// 2. 模块加载函数
int lua_openmylib(lua_State *L) {
    luaL_newlib(L, mylib_funcs); // 创建表存储模块函数，压入栈
    return 1; // 返回模块表
}

// 3. 注册模块到 Lua
const luaL_Reg lua_reg_libs[] = {
    {"base", luaopen_base}, // Lua 基础库
    {"mylib", lua_openmylib}, // 自定义模块（名：mylib）
    {NULL, NULL}
};

// 4. Lua 脚本调用：local sum = mylib.add(10,20) → 30
```

#### Lua 与 C#（XLua）交互

核心原理

- 基于 C API 封装，通过 **P/Invoke** （托管代码中访问非托管库中的结构、回调和函数） 调用 Lua 虚拟机函数（核心封装类：`LuaDLL.cs`、`LuaAPI.cs`）
- C# 对象在 Lua 中以 `userdata` 形式存在，通过「**索引**」保持引用，元表（metatable）存储类型信息（方法、属性）
- 数据交互依赖 `ObjectTranslator`：管理 C# 与 Lua 对象的映射、类型注册、垃圾回收同步

##### C#（XLua）调用 Lua

（1）核心方式：类型映射

- 引用类型映射：实现 `LuaBase` 接口（如 `LuaTable`、`LuaFunction`），标记 `[CSharpCallLua]` 特性，双向同步修改
- 值类型映射：直接取值，无后续关联（如 `int`、`string`）

（2）操作示例

① 获取 Lua 全局变量 / 表

```csharp
// 创建 Lua 环境
LuaEnv luaEnv = new LuaEnv();
// 加载并运行 Lua 脚本
luaEnv.DoString(@"
    str = 'I am x-man.'
    tbl = {name = 'DC', id = 20114442}
");

// 获取全局变量 str（值类型）
string str = luaEnv.Global.Get<string>("str");
Console.WriteLine("str = " + str);

// 获取表 tbl（引用类型）
LuaTable tbl = luaEnv.Global.Get<LuaTable>("tbl");
string name = tbl.Get<string>("name");
int id = tbl.Get<int>("id");
Console.WriteLine("tbl:name = " + name + ", tbl:id = " + id);

// 释放环境
luaEnv.Dispose();
```

② 调用 Lua 函数

```csharp
// Lua 脚本：function add(a,b) return a + b end
LuaEnv luaEnv = new LuaEnv();
luaEnv.DoString("function add(a,b) return a + b end");

// 方式1：通过 LuaFunction 调用
LuaFunction addFunc = luaEnv.Global.Get<LuaFunction>("add");
object[] result = addFunc.Call(10, 20);
Console.WriteLine("Result = " + result[0]); // 输出 30

// 方式2：映射为委托（推荐，类型安全）
[CSharpCallLua]
public delegate int AddDelegate(int a, int b);

AddDelegate add = luaEnv.Global.Get<AddDelegate>("add");
int sum = add(10, 20);
Console.WriteLine("Sum = " + sum); // 输出 30

luaEnv.Dispose();
```

##### Lua 调用 C#

（1）核心流程

1. 注册 C# 类型 / 函数到 Lua：通过生成 `wrap` 代码（静态方法，封装 C# 逻辑）或反射
2. Lua 中通过 `CS.命名空间.类型` 调用（如 `CS.UnityEngine.GameObject`）

（2）操作示例

① 注册 C# 类与方法

```csharp
// 1. 定义 C# 类
public class Test {
    public string Name { get; set; }
    public int Add(int a, int b) { return a + b; }
    public static void Log(string msg) { Console.WriteLine(msg); }
}

// 2. 生成 wrap 代码（需配置 XLua 生成规则），或通过反射注册
// 3. Lua 脚本调用
luaEnv.DoString(@"
    -- 创建实例
    local test = CS.Test()
    test.Name = 'DC'
    print(test.Name) -- 输出 DC
    
    -- 调用实例方法
    local sum = test.Add(10,20)
    print(sum) -- 输出 30
    
    -- 调用静态方法
    CS.Test.Log('Hello XLua') -- 输出 Hello XLua
");
```

② 注册 C# 委托（Lua 调用 C# 委托）

```csharp
// 1. 定义委托并标记特性
[CSharpCallLua]
public delegate void LogDelegate(string msg);

// 2. C# 中定义委托方法
public static void CSharpLog(string msg) {
    Console.WriteLine("CSharpLog: " + msg);
}

// 3. 注册到 Lua
LuaEnv luaEnv = new LuaEnv();
luaEnv.Global.Set("CSharpLog", new LogDelegate(CSharpLog));

// 4. Lua 脚本调用
luaEnv.DoString("CSharpLog('From Lua')"); // 输出 CSharpLog: From Lua
```



关键差异对比

| 维度     | Lua 与 C++                        | Lua 与 C#（XLua）                                            |
| -------- | --------------------------------- | ------------------------------------------------------------ |
| 调用底层 | 直接调用 Lua C API                | 基于 P/Invoke 封装 C API                                     |
| 对象映射 | 无自动映射，需手动处理指针 / 索引 | `ObjectTranslator` 自动管理对象索引与元表                    |
| 代码生成 | 无需额外生成代码                  | 需生成 `` 代码（或依赖反射），支持特性标记（如 `[CSharpCallLua]`） |
| 垃圾回收 | 需手动同步栈与对象生命周期        | 自动同步（基于 `__gc` 元方法与 `Dispose`）                   |
| 易用性   | 灵活性高，需手动处理栈操作        |                                                              |





## 计算机基础

### 链接

#### 静态链接、动态链接？

**静态链接**：编译器和汇编器将多个文件（模块）生成多个**可重定位的目标文件**，**静态链接器**在链接时将多个可重定位目标文件链接成可执行的文件（exe，.out 文件 ELF 格式）![img](D:\Projects\NOTES\images\v2-cfa13f874f3e9a2a43212ed57017277a_1440w.jpg)

**动态链接**：动态链接器需要在链接时先通过静态链接器传入一些重定位和符号信息，后续在可执行文件加载或者运行的时候先加载动态链接器（.interp 节中和包含动态链接器的路径，他本身就是一个共享库），随后根据重定位等信息将目标动态库文件加载到内存中。

![img](D:\Projects\NOTES\images\v2-e0a3804729d32b7b81f156cab6fc36b6_1440w.jpg)

#### 静态库、动态库？

**静态库**：任意个. o 文件的集合，程序 link 时，被复制到 output 文件。这个静态库文件是静态编译出来的，索引和实现都在其中，可以直接加到内存里面执行。

对于 Windows 上的静态库 .lib 有两种，一种和上面描述的一样，是任意个. o 文件的集合。程序 link 时，随程序直接加载到内存里面。另一种是辅助动态链接的实现（**导入库**），包含函数的描述和在 DLL 中的位置。也就是说，它为存放函数实现的 dll 提供索引功能，为了找到 dll 中的函数实现的入口点，程序 link 时，根据函数的位置生成函数调用的 jump 指令。（Linux 下动态链接器不需要导入库）

**动态库**：包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。（Linux 下. so 为后缀）



#### 内部链接、外部链接？

| **特性**       | **外部链接 (External)**                   | **内部链接 (Internal)**         |
| -------------- | ----------------------------------------- | ------------------------------- |
| **关键字**     | `extern` (默认)                           | `static` (全局), `const`        |
| **可见范围**   | 整个程序（跨 `.cpp`）                     | 仅限当前编译单元（当前 `.cpp`） |
| **符号表状态** | 导出为全局符号                            | 标记为私有/局部符号             |
| **典型用途**   | 全局共享配置、库函数                      | 隐藏辅助函数、常量定义          |
| **冲突风险**   | 高（容易发生 "multiple definition" 错误） | 低（文件名相同也不会报错）      |



## UE

 [UE.md](..\UE.md) 